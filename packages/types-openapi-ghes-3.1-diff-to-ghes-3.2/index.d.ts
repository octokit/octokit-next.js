/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/admin/tokens": {
    /** Lists personal access tokens for all users, including admin users. */
    get: operations["enterprise-admin/list-personal-access-tokens"];
  };
  "/admin/users/{username}/authorizations": {
    post: operations["enterprise-admin/create-impersonation-o-auth-token"];
  };
  "/app/installations/{installation_id}/access_tokens": {
    /**
     * Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
     *
     * You must use a [JWT](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
     */
    post: operations["apps/create-installation-access-token"];
  };
  "/applications/{client_id}/token": {
    /** OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`. */
    post: operations["apps/check-token"];
    /** OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`. */
    patch: operations["apps/reset-token"];
  };
  "/applications/{client_id}/token/scoped": {
    /** Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission scoped user-to-server OAuth access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`. */
    post: operations["apps/scope-token"];
  };
  "/applications/{client_id}/tokens/{access_token}": {
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     */
    get: operations["apps/check-authorization"];
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     */
    post: operations["apps/reset-authorization"];
  };
  "/authorizations": {
    /** **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/). */
    get: operations["oauth-authorizations/list-authorizations"];
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
     *
     * Creates OAuth tokens using [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * To create tokens for a particular OAuth application using this endpoint, you must authenticate as the user you want to create an authorization for and provide the app's client ID and secret, found on your OAuth application's settings page. If your OAuth application intends to create multiple tokens for one user, use `fingerprint` to differentiate between them.
     *
     * You can also create tokens on GitHub Enterprise Server from the [personal access tokens settings](https://github.com/settings/tokens) page. Read more about these tokens in [the GitHub Help documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
     *
     * Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about allowing tokens in [the GitHub Help documentation](https://help.github.com/articles/about-identity-and-access-management-with-saml-single-sign-on).
     */
    post: operations["oauth-authorizations/create-authorization"];
  };
  "/authorizations/clients/{client_id}": {
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
     *
     * Creates a new authorization for the specified OAuth application, only if an authorization for that application doesn't already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
     *
     * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     */
    put: operations["oauth-authorizations/get-or-create-authorization-for-app"];
  };
  "/authorizations/clients/{client_id}/{fingerprint}": {
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
     *
     * This method will create a new authorization for the specified OAuth application, only if an authorization for that application and fingerprint do not already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint` is a unique string to distinguish an authorization from others created for the same client ID and user. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
     *
     * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     */
    put: operations["oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint"];
  };
  "/authorizations/{authorization_id}": {
    /** **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/). */
    get: operations["oauth-authorizations/get-authorization"];
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
     *
     * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
     *
     * You can only send one of these scope keys at a time.
     */
    patch: operations["oauth-authorizations/update-authorization"];
  };
  "/enterprises/{enterprise}/actions/runners/registration-token": {
    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * #### Example using registration token
     *
     * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
     *
     * ```
     * ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
     * ```
     */
    post: operations["enterprise-admin/create-registration-token-for-enterprise"];
  };
  "/enterprises/{enterprise}/actions/runners/remove-token": {
    /**
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an enterprise. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     *
     * #### Example using remove token
     *
     * To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token provided by this
     * endpoint.
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     */
    post: operations["enterprise-admin/create-remove-token-for-enterprise"];
  };
  "/events": {
    /** We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago. */
    get: operations["activity/list-public-events"];
  };
  "/installation/repositories": {
    /**
     * List repositories that an app installation can access.
     *
     * You must use an [installation access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     */
    get: operations["apps/list-repos-accessible-to-installation"];
  };
  "/issues": {
    /**
     * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
     * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
     * necessarily assigned to you.
     *
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list"];
  };
  "/networks/{owner}/{repo}/events": {
    get: operations["activity/list-public-events-for-repo-network"];
  };
  "/notifications": {
    /** List all notifications for the current user, sorted by most recently updated. */
    get: operations["activity/list-notifications-for-authenticated-user"];
  };
  "/notifications/threads/{thread_id}": {
    get: operations["activity/get-thread"];
  };
  "/orgs/{org}/actions/permissions/repositories": {
    /**
     * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     */
    get: operations["actions/list-selected-repositories-enabled-github-actions-organization"];
  };
  "/orgs/{org}/actions/runner-groups/{runner_group_id}/repositories": {
    /**
     * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
     *
     * Lists the repositories with access to a self-hosted runner group configured in an organization.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     */
    get: operations["actions/list-repo-access-to-self-hosted-runner-group-in-org"];
  };
  "/orgs/{org}/actions/runners/registration-token": {
    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * #### Example using registration token
     *
     * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
     *
     * ```
     * ./config.sh --url https://github.com/octo-org --token TOKEN
     * ```
     */
    post: operations["actions/create-registration-token-for-org"];
  };
  "/orgs/{org}/actions/runners/remove-token": {
    /**
     * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
     *
     * #### Example using remove token
     *
     * To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
     * endpoint.
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     */
    post: operations["actions/create-remove-token-for-org"];
  };
  "/orgs/{org}/actions/secrets/{secret_name}/repositories": {
    /** Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. */
    get: operations["actions/list-selected-repos-for-org-secret"];
  };
  "/orgs/{org}/events": {
    get: operations["activity/list-public-org-events"];
  };
  "/orgs/{org}/hooks": {
    get: operations["orgs/list-webhooks"];
    /** Here's how you can create a hook that posts payloads in JSON format: */
    post: operations["orgs/create-webhook"];
  };
  "/orgs/{org}/hooks/{hook_id}": {
    /** Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)." */
    get: operations["orgs/get-webhook"];
    /** Updates a webhook configured in an organization. When you update a webhook, the `secret` will be overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for an organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization)." */
    patch: operations["orgs/update-webhook"];
  };
  "/orgs/{org}/issues": {
    /**
     * List issues in an organization assigned to the authenticated user.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list-for-org"];
  };
  "/orgs/{org}/repos": {
    /** Lists repositories for the specified organization. */
    get: operations["repos/list-for-org"];
    /**
     * Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
     *
     * **OAuth scope requirements**
     *
     * When using [OAuth](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
     *
     * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
     * *   `repo` scope to create a private repository
     */
    post: operations["repos/create-in-org"];
  };
  "/orgs/{org}/teams/{team_slug}/repos": {
    /**
     * Lists a team's repositories visible to the authenticated user.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
     */
    get: operations["teams/list-repos-in-org"];
  };
  "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}": {
    /**
     * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
     *
     * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
     *
     * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
     */
    get: operations["teams/check-permissions-for-repo-in-org"];
  };
  "/repos/{owner}/{repo}": {
    /**
     * When you pass the `scarlet-witch-preview` media type, requests to get a repository will also return the repository's code of conduct if it can be detected from the repository's code of conduct file.
     *
     * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
     */
    get: operations["repos/get"];
    /** **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#replace-all-repository-topics) endpoint. */
    patch: operations["repos/update"];
  };
  "/repos/{owner}/{repo}/actions/runners/registration-token": {
    /**
     * Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
     * using an access token with the `repo` scope to use this endpoint.
     *
     * #### Example using registration token
     *
     * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
     *
     * ```
     * ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
     * ```
     */
    post: operations["actions/create-registration-token-for-repo"];
  };
  "/repos/{owner}/{repo}/actions/runners/remove-token": {
    /**
     * Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
     * You must authenticate using an access token with the `repo` scope to use this endpoint.
     *
     * #### Example using remove token
     *
     * To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.
     *
     * ```
     * ./config.sh remove --token TOKEN
     * ```
     */
    post: operations["actions/create-remove-token-for-repo"];
  };
  "/repos/{owner}/{repo}/actions/runs": {
    /**
     * Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
     */
    get: operations["actions/list-workflow-runs-for-repo"];
  };
  "/repos/{owner}/{repo}/actions/runs/{run_id}": {
    /** Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. */
    get: operations["actions/get-workflow-run"];
  };
  "/repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs": {
    /**
     * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#parameters).
     *
     * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
     */
    get: operations["actions/list-workflow-runs"];
  };
  "/repos/{owner}/{repo}/check-suites": {
    /**
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
     *
     * By default, check suites are automatically created when you create a [check run](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must have the `checks:write` permission to create check suites.
     */
    post: operations["checks/create-suite"];
  };
  "/repos/{owner}/{repo}/check-suites/preferences": {
    /** Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites. */
    patch: operations["checks/set-suites-preferences"];
  };
  "/repos/{owner}/{repo}/check-suites/{check_suite_id}": {
    /**
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
     *
     * Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
     */
    get: operations["checks/get-suite"];
  };
  "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}": {
    /**
     * Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * **Deprecation notice**:
     * The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
     */
    get: operations["code-scanning/get-alert"];
    /** Updates the status of a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint. */
    patch: operations["code-scanning/update-alert"];
  };
  "/repos/{owner}/{repo}/collaborators/{username}": {
    /**
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
     *
     * For more information the permission levels, see "[Repository permission levels for an organization](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-verbs)."
     *
     * The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#invitations).
     *
     * **Rate limits**
     *
     * You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
     */
    put: operations["repos/add-collaborator"];
  };
  "/repos/{owner}/{repo}/commits/{commit_sha}/pulls": {
    /** Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. Additional preview headers may be required to see certain details for associated pull requests, such as whether a pull request is in a draft state. For more information about previews that might affect this endpoint, see the [List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests) endpoint. */
    get: operations["repos/list-pull-requests-associated-with-commit"];
  };
  "/repos/{owner}/{repo}/commits/{ref}/check-suites": {
    /**
     * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
     *
     * Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
     */
    get: operations["checks/list-suites-for-ref"];
  };
  "/repos/{owner}/{repo}/commits/{ref}/status": {
    /**
     * Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
     *
     * The most recent status for each context is returned, up to 100. This field [paginates](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination) if there are over 100 contexts.
     *
     * Additionally, a combined `state` is returned. The `state` is one of:
     *
     * *   **failure** if any of the contexts report as `error` or `failure`
     * *   **pending** if there are no statuses or a context is `pending`
     * *   **success** if the latest status for all contexts is `success`
     */
    get: operations["repos/get-combined-status-for-ref"];
  };
  "/repos/{owner}/{repo}/compare/{basehead}": {
    /**
     * The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.
     *
     * The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
     *
     * The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
     *
     * **Working with large comparisons**
     *
     * The response will include a comparison of up to 250 commits. If you are working with a larger commit range, you can use the [List commits](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-commits) to enumerate all commits in the range.
     *
     * For comparisons with extremely large diffs, you may receive an error response indicating that the diff took too long
     * to generate. You can typically resolve this error by using a smaller commit range.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     */
    get: operations["repos/compare-commits-with-basehead"];
  };
  "/repos/{owner}/{repo}/events": {
    get: operations["activity/list-repo-events"];
  };
  "/repos/{owner}/{repo}/forks": {
    get: operations["repos/list-forks"];
    /**
     * Create a fork for the authenticated user.
     *
     * **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Enterprise Server Support](https://support.github.com/contact?tags=dotcom-rest-api).
     */
    post: operations["repos/create-fork"];
  };
  "/repos/{owner}/{repo}/hooks": {
    get: operations["repos/list-webhooks"];
    /**
     * Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
     * share the same `config` as long as those webhooks do not have any `events` that overlap.
     */
    post: operations["repos/create-webhook"];
  };
  "/repos/{owner}/{repo}/hooks/{hook_id}": {
    /** Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)." */
    get: operations["repos/get-webhook"];
    /** Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository)." */
    patch: operations["repos/update-webhook"];
  };
  "/repos/{owner}/{repo}/invitations": {
    /** When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations. */
    get: operations["repos/list-invitations"];
  };
  "/repos/{owner}/{repo}/invitations/{invitation_id}": {
    patch: operations["repos/update-invitation"];
  };
  "/repos/{owner}/{repo}/issues": {
    /**
     * List issues in a repository.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list-for-repo"];
    /**
     * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
     */
    post: operations["issues/create"];
  };
  "/repos/{owner}/{repo}/issues/events": {
    get: operations["issues/list-events-for-repo"];
  };
  "/repos/{owner}/{repo}/issues/events/{event_id}": {
    get: operations["issues/get-event"];
  };
  "/repos/{owner}/{repo}/issues/{issue_number}": {
    /**
     * The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
     * [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
     * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
     * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
     * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
     * to the [`issues`](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#issues) webhook.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/get"];
    /** Issue owners and users with push access can edit an issue. */
    patch: operations["issues/update"];
  };
  "/repos/{owner}/{repo}/issues/{issue_number}/assignees": {
    /** Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced. */
    post: operations["issues/add-assignees"];
  };
  "/repos/{owner}/{repo}/notifications": {
    /** List all notifications for the current user. */
    get: operations["activity/list-repo-notifications-for-authenticated-user"];
  };
  "/repos/{owner}/{repo}/pulls": {
    /** Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. */
    get: operations["pulls/list"];
  };
  "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers": {
    /** This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.1/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details. */
    post: operations["pulls/request-reviewers"];
  };
  "/repos/{owner}/{repo}/releases": {
    /**
     * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-repository-tags).
     *
     * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
     */
    get: operations["repos/list-releases"];
    /**
     * Users with push access to the repository can create a release.
     *
     * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
     */
    post: operations["repos/create-release"];
  };
  "/repos/{owner}/{repo}/releases/latest": {
    /**
     * View the latest published full release for the repository.
     *
     * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
     */
    get: operations["repos/get-latest-release"];
  };
  "/repos/{owner}/{repo}/releases/tags/{tag}": {
    /** Get a published release with the specified tag. */
    get: operations["repos/get-release-by-tag"];
  };
  "/repos/{owner}/{repo}/releases/{release_id}": {
    /** **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#hypermedia). */
    get: operations["repos/get-release"];
    /** Users with push access to the repository can edit a release. */
    patch: operations["repos/update-release"];
  };
  "/repos/{owner}/{repo}/transfer": {
    /** A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://help.github.com/articles/about-repository-transfers/). */
    post: operations["repos/transfer"];
  };
  "/repos/{template_owner}/{template_repo}/generate": {
    /**
     * Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. The authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
     *
     * **OAuth scope requirements**
     *
     * When using [OAuth](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
     *
     * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
     * *   `repo` scope to create a private repository
     */
    post: operations["repos/create-using-template"];
  };
  "/repositories": {
    /**
     * Lists all public repositories in the order that they were created.
     *
     * Note:
     * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
     * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
     */
    get: operations["repos/list-public"];
  };
  "/search/code": {
    /**
     * Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
     *
     * `q=addClass+in:file+language:js+repo:jquery/jquery`
     *
     * This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.
     *
     * #### Considerations for code search
     *
     * Due to the complexity of searching code, there are a few restrictions on how searches are performed:
     *
     * *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
     * *   Only files smaller than 384 KB are searchable.
     * *   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
     * language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
     */
    get: operations["search/code"];
  };
  "/search/commits": {
    /**
     * Find commits via various criteria on the default branch (usually `master`). This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
     * metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:
     *
     * `q=repo:octocat/Spoon-Knife+css`
     */
    get: operations["search/commits"];
  };
  "/search/issues": {
    /**
     * Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
     * search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
     *
     * `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
     *
     * This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
     *
     * **Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
     */
    get: operations["search/issues-and-pull-requests"];
  };
  "/search/repositories": {
    /**
     * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
     *
     * `q=tetris+language:assembly&sort=stars&order=desc`
     *
     * This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
     *
     * When you include the `mercy` preview header, you can also search for multiple topics by adding more `topic:` instances. For example, your query might look like this:
     *
     * `q=topic:ruby+topic:rails`
     */
    get: operations["search/repos"];
  };
  "/teams/{team_id}/repos": {
    /** **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/enterprise-server@3.1/rest/reference/teams#list-team-repositories) endpoint. */
    get: operations["teams/list-repos-legacy"];
  };
  "/teams/{team_id}/repos/{owner}/{repo}": {
    /**
     * **Note**: Repositories inherited through a parent team will also be checked.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/enterprise-server@3.1/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
     *
     * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
     */
    get: operations["teams/check-permissions-for-repo-legacy"];
  };
  "/user/installations/{installation_id}/repositories": {
    /**
     * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     *
     * You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
     *
     * The access the user has to each repository is included in the hash under the `permissions` key.
     */
    get: operations["apps/list-installation-repos-for-authenticated-user"];
  };
  "/user/issues": {
    /**
     * List issues across owned and member repositories assigned to the authenticated user.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list-for-authenticated-user"];
  };
  "/user/repos": {
    /**
     * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     */
    get: operations["repos/list-for-authenticated-user"];
    /**
     * Creates a new repository for the authenticated user.
     *
     * **OAuth scope requirements**
     *
     * When using [OAuth](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
     *
     * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
     * *   `repo` scope to create a private repository.
     */
    post: operations["repos/create-for-authenticated-user"];
  };
  "/user/repository_invitations": {
    /** When authenticating as a user, this endpoint will list all currently open repository invitations for that user. */
    get: operations["repos/list-invitations-for-authenticated-user"];
  };
  "/user/starred": {
    /**
     * Lists repositories the authenticated user has starred.
     *
     * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
     */
    get: operations["activity/list-repos-starred-by-authenticated-user"];
  };
  "/user/subscriptions": {
    /** Lists repositories the authenticated user is watching. */
    get: operations["activity/list-watched-repos-for-authenticated-user"];
  };
  "/users/{username}/events": {
    /** If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. */
    get: operations["activity/list-events-for-authenticated-user"];
  };
  "/users/{username}/events/orgs/{org}": {
    /** This is the user's organization dashboard. You must be authenticated as the user to view this. */
    get: operations["activity/list-org-events-for-authenticated-user"];
  };
  "/users/{username}/events/public": {
    get: operations["activity/list-public-events-for-user"];
  };
  "/users/{username}/received_events": {
    /** These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events. */
    get: operations["activity/list-received-events-for-user"];
  };
  "/users/{username}/received_events/public": {
    get: operations["activity/list-received-public-events-for-user"];
  };
  "/users/{username}/repos": {
    /** Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal repositories for the specified user. */
    get: operations["repos/list-for-user"];
  };
  "/users/{username}/subscriptions": {
    /** Lists repositories a user is watching. */
    get: operations["activity/list-repos-watched-by-user"];
  };
}

export interface components {
  schemas: {
    /** The authorization for an OAuth app, GitHub App, or a Personal Access Token. */
    authorization: {
      id: number;
      url: string;
      /** A list of scopes that this authorization is in. */
      scopes: string[] | null;
      token: string;
      token_last_eight: string | null;
      hashed_token: string | null;
      app: {
        client_id: string;
        name: string;
        url: string;
      };
      note: string | null;
      note_url: string | null;
      updated_at: string;
      created_at: string;
      fingerprint: string | null;
      user?: components["schemas"]["nullable-simple-user"];
      installation?: components["schemas"]["nullable-scoped-installation"];
    } & {
      expires_at: unknown;
    };
    /** The permissions granted to the user-to-server access token. */
    "app-permissions": {
      /** The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts. Can be one of: `read` or `write`. */
      actions?: "read" | "write";
      /** The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation. Can be one of: `read` or `write`. */
      administration?: "read" | "write";
      /** The level of permission to grant the access token for checks on code. Can be one of: `read` or `write`. */
      checks?: "read" | "write";
      /** The level of permission to grant the access token for notification of content references and creation content attachments. Can be one of: `read` or `write`. */
      content_references?: "read" | "write";
      /** The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges. Can be one of: `read` or `write`. */
      contents?: "read" | "write";
      /** The level of permission to grant the access token for deployments and deployment statuses. Can be one of: `read` or `write`. */
      deployments?: "read" | "write";
      /** The level of permission to grant the access token for managing repository environments. Can be one of: `read` or `write`. */
      environments?: "read" | "write";
      /** The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones. Can be one of: `read` or `write`. */
      issues?: "read" | "write";
      /** The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata. Can be one of: `read` or `write`. */
      metadata?: "read" | "write";
      /** The level of permission to grant the access token for packages published to GitHub Packages. Can be one of: `read` or `write`. */
      packages?: "read" | "write";
      /** The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds. Can be one of: `read` or `write`. */
      pages?: "read" | "write";
      /** The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges. Can be one of: `read` or `write`. */
      pull_requests?: "read" | "write";
      /** The level of permission to grant the access token to manage the post-receive hooks for a repository. Can be one of: `read` or `write`. */
      repository_hooks?: "read" | "write";
      /** The level of permission to grant the access token to manage repository projects, columns, and cards. Can be one of: `read`, `write`, or `admin`. */
      repository_projects?: "read" | "write" | "admin";
      /** The level of permission to grant the access token to view and manage secret scanning alerts. Can be one of: `read` or `write`. */
      secret_scanning_alerts?: "read" | "write";
      /** The level of permission to grant the access token to manage repository secrets. Can be one of: `read` or `write`. */
      secrets?: "read" | "write";
      /** The level of permission to grant the access token to view and manage security events like code scanning alerts. Can be one of: `read` or `write`. */
      security_events?: "read" | "write";
      /** The level of permission to grant the access token to manage just a single file. Can be one of: `read` or `write`. */
      single_file?: "read" | "write";
      /** The level of permission to grant the access token for commit statuses. Can be one of: `read` or `write`. */
      statuses?: "read" | "write";
      /** The level of permission to grant the access token to retrieve Dependabot alerts. Can be one of: `read`. */
      vulnerability_alerts?: "read";
      /** The level of permission to grant the access token to update GitHub Actions workflow files. Can be one of: `write`. */
      workflows?: "write";
      /** The level of permission to grant the access token for organization teams and members. Can be one of: `read` or `write`. */
      members?: "read" | "write";
      /** The level of permission to grant the access token to manage access to an organization. Can be one of: `read` or `write`. */
      organization_administration?: "read" | "write";
      /** The level of permission to grant the access token to manage the post-receive hooks for an organization. Can be one of: `read` or `write`. */
      organization_hooks?: "read" | "write";
      /** The level of permission to grant the access token for viewing an organization's plan. Can be one of: `read`. */
      organization_plan?: "read";
      /** The level of permission to grant the access token to manage organization projects, columns, and cards. Can be one of: `read`, `write`, or `admin`. */
      organization_projects?: "read" | "write" | "admin";
      /** The level of permission to grant the access token for organization packages published to GitHub Packages. Can be one of: `read` or `write`. */
      organization_packages?: "read" | "write";
      /** The level of permission to grant the access token to manage organization secrets. Can be one of: `read` or `write`. */
      organization_secrets?: "read" | "write";
      /** The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization. Can be one of: `read` or `write`. */
      organization_self_hosted_runners?: "read" | "write";
      /** The level of permission to grant the access token to view and manage users blocked by the organization. Can be one of: `read` or `write`. */
      organization_user_blocking?: "read" | "write";
      /** The level of permission to grant the access token to manage team discussions and related comments. Can be one of: `read` or `write`. */
      team_discussions?: "read" | "write";
    };
    /** Authentication token for a GitHub App installed on a user or org. */
    "installation-token": {
      token: string;
      expires_at: string;
      permissions?: components["schemas"]["app-permissions"];
      repository_selection?: "all" | "selected";
      repositories?: components["schemas"]["repository"][];
      single_file?: string;
      has_multiple_single_files?: boolean;
      single_file_paths?: string[];
    };
    /** The authorization for an OAuth app, GitHub App, or a Personal Access Token. */
    "nullable-authorization":
      | ({
          id: number;
          url: string;
          /** A list of scopes that this authorization is in. */
          scopes: string[] | null;
          token: string;
          token_last_eight: string | null;
          hashed_token: string | null;
          app: {
            client_id: string;
            name: string;
            url: string;
          };
          note: string | null;
          note_url: string | null;
          updated_at: string;
          created_at: string;
          fingerprint: string | null;
          user?: components["schemas"]["nullable-simple-user"];
          installation?: components["schemas"]["nullable-scoped-installation"];
        } & {
          expires_at: unknown;
        })
      | null;
    /** Authentication Token */
    "authentication-token": {
      /** The token used for authentication */
      token: string;
      /** The time this token expires */
      expires_at: string;
      permissions?: { [key: string]: unknown };
      /** The repositories this token has access to */
      repositories?: components["schemas"]["repository"][];
      single_file?: string | null;
      /** Describe whether all repositories have been selected or there's a selection involved */
      repository_selection?: "all" | "selected";
    };
    /** Event */
    event: {
      id: string;
      type: string | null;
      actor: components["schemas"]["actor"];
      repo: {
        id: number;
        name: string;
        url: string;
      };
      org?: components["schemas"]["actor"];
      payload: {
        action?: string;
        issue?: components["schemas"]["issue-simple"];
        comment?: components["schemas"]["issue-comment"];
        pages?: {
          page_name?: string;
          title?: string;
          summary?: string | null;
          action?: string;
          sha?: string;
          html_url?: string;
        }[];
      };
      public: boolean;
      created_at: string | null;
    };
    /** A git repository */
    repository: {
      /** Unique identifier of the repository */
      id: number;
      node_id: string;
      /** The name of the repository. */
      name: string;
      full_name: string;
      license: components["schemas"]["nullable-license-simple"];
      organization?: components["schemas"]["nullable-simple-user"];
      forks: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
      };
      owner: components["schemas"]["simple-user"];
      /** Whether the repository is private or public. */
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      /** The default branch of the repository. */
      default_branch: string;
      open_issues_count: number;
      /** Whether this repository acts as a template that can be used to generate new repositories. */
      is_template?: boolean;
      topics?: string[];
      /** Whether issues are enabled. */
      has_issues: boolean;
      /** Whether projects are enabled. */
      has_projects: boolean;
      /** Whether the wiki is enabled. */
      has_wiki: boolean;
      has_pages: boolean;
      /** Whether downloads are enabled. */
      has_downloads: boolean;
      /** Whether the repository is archived. */
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string | null;
      created_at: string | null;
      updated_at: string | null;
      /** Whether to allow rebase merges for pull requests. */
      allow_rebase_merge?: boolean;
      template_repository?: {
        id?: number;
        node_id?: string;
        name?: string;
        full_name?: string;
        owner?: {
          login?: string;
          id?: number;
          node_id?: string;
          avatar_url?: string;
          gravatar_id?: string;
          url?: string;
          html_url?: string;
          followers_url?: string;
          following_url?: string;
          gists_url?: string;
          starred_url?: string;
          subscriptions_url?: string;
          organizations_url?: string;
          repos_url?: string;
          events_url?: string;
          received_events_url?: string;
          type?: string;
          site_admin?: boolean;
        };
        private?: boolean;
        html_url?: string;
        description?: string;
        fork?: boolean;
        url?: string;
        archive_url?: string;
        assignees_url?: string;
        blobs_url?: string;
        branches_url?: string;
        collaborators_url?: string;
        comments_url?: string;
        commits_url?: string;
        compare_url?: string;
        contents_url?: string;
        contributors_url?: string;
        deployments_url?: string;
        downloads_url?: string;
        events_url?: string;
        forks_url?: string;
        git_commits_url?: string;
        git_refs_url?: string;
        git_tags_url?: string;
        git_url?: string;
        issue_comment_url?: string;
        issue_events_url?: string;
        issues_url?: string;
        keys_url?: string;
        labels_url?: string;
        languages_url?: string;
        merges_url?: string;
        milestones_url?: string;
        notifications_url?: string;
        pulls_url?: string;
        releases_url?: string;
        ssh_url?: string;
        stargazers_url?: string;
        statuses_url?: string;
        subscribers_url?: string;
        subscription_url?: string;
        tags_url?: string;
        teams_url?: string;
        trees_url?: string;
        clone_url?: string;
        mirror_url?: string;
        hooks_url?: string;
        svn_url?: string;
        homepage?: string;
        language?: string;
        forks_count?: number;
        stargazers_count?: number;
        watchers_count?: number;
        size?: number;
        default_branch?: string;
        open_issues_count?: number;
        is_template?: boolean;
        topics?: string[];
        has_issues?: boolean;
        has_projects?: boolean;
        has_wiki?: boolean;
        has_pages?: boolean;
        has_downloads?: boolean;
        archived?: boolean;
        disabled?: boolean;
        visibility?: string;
        pushed_at?: string;
        created_at?: string;
        updated_at?: string;
        permissions?: {
          admin?: boolean;
          maintain?: boolean;
          push?: boolean;
          triage?: boolean;
          pull?: boolean;
        };
        allow_rebase_merge?: boolean;
        temp_clone_token?: string;
        allow_squash_merge?: boolean;
        delete_branch_on_merge?: boolean;
        allow_merge_commit?: boolean;
        subscribers_count?: number;
        network_count?: number;
      } | null;
      temp_clone_token?: string;
      /** Whether to allow squash merges for pull requests. */
      allow_squash_merge?: boolean;
      /** Whether to delete head branches when pull requests are merged */
      delete_branch_on_merge?: boolean;
      /** Whether to allow merge commits for pull requests. */
      allow_merge_commit?: boolean;
      /** Whether to allow forking this repo */
      allow_forking?: boolean;
      subscribers_count?: number;
      network_count?: number;
      open_issues: number;
      watchers: number;
      master_branch?: string;
      starred_at?: string;
    };
    /** Issues are a great way to keep track of tasks, enhancements, and bugs for your projects. */
    issue: {
      id: number;
      node_id: string;
      /** URL for the issue */
      url: string;
      repository_url: string;
      labels_url: string;
      comments_url: string;
      events_url: string;
      html_url: string;
      /** Number uniquely identifying the issue within its repository */
      number: number;
      /** State of the issue; either 'open' or 'closed' */
      state: string;
      /** Title of the issue */
      title: string;
      /** Contents of the issue */
      body?: string | null;
      user: components["schemas"]["nullable-simple-user"];
      /** Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository */
      labels: (
        | string
        | {
            id?: number;
            node_id?: string;
            url?: string;
            name?: string;
            description?: string | null;
            color?: string | null;
            default?: boolean;
          }
      )[];
      assignee: components["schemas"]["nullable-simple-user"];
      assignees?: components["schemas"]["simple-user"][] | null;
      milestone: components["schemas"]["nullable-milestone"];
      locked: boolean;
      active_lock_reason?: string | null;
      comments: number;
      pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
      };
      closed_at: string | null;
      created_at: string;
      updated_at: string;
      closed_by?: components["schemas"]["nullable-simple-user"];
      body_html?: string;
      body_text?: string;
      timeline_url?: string;
      repository?: components["schemas"]["repository"];
      performed_via_github_app?: components["schemas"]["nullable-integration"];
      author_association: components["schemas"]["author_association"];
      reactions?: components["schemas"]["reaction-rollup"];
    };
    /** Thread */
    thread: {
      id: string;
      repository: components["schemas"]["minimal-repository"];
      subject: {
        title: string;
        url: string;
        latest_comment_url: string;
        type: string;
      };
      reason: string;
      unread: boolean;
      updated_at: string;
      last_read_at: string | null;
      url: string;
      subscription_url: string;
    };
    /** Minimal Repository */
    "minimal-repository": {
      id: number;
      node_id: string;
      name: string;
      full_name: string;
      owner: components["schemas"]["simple-user"];
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url?: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url?: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url?: string;
      mirror_url?: string | null;
      hooks_url: string;
      svn_url?: string;
      homepage?: string | null;
      language?: string | null;
      forks_count?: number;
      stargazers_count?: number;
      watchers_count?: number;
      size?: number;
      default_branch?: string;
      open_issues_count?: number;
      is_template?: boolean;
      topics?: string[];
      has_issues?: boolean;
      has_projects?: boolean;
      has_wiki?: boolean;
      has_pages?: boolean;
      has_downloads?: boolean;
      archived?: boolean;
      disabled?: boolean;
      visibility?: string;
      pushed_at?: string | null;
      created_at?: string | null;
      updated_at?: string | null;
      permissions?: {
        admin?: boolean;
        maintain?: boolean;
        push?: boolean;
        triage?: boolean;
        pull?: boolean;
      };
      template_repository?: components["schemas"]["nullable-repository"];
      temp_clone_token?: string;
      delete_branch_on_merge?: boolean;
      subscribers_count?: number;
      network_count?: number;
      code_of_conduct?: components["schemas"]["code-of-conduct"];
      license?: {
        key?: string;
        name?: string;
        spdx_id?: string;
        url?: string;
        node_id?: string;
      } | null;
      forks?: number;
      open_issues?: number;
      watchers?: number;
      allow_forking?: boolean;
    };
    /** Org Hook */
    "org-hook": {
      id: number;
      url: string;
      ping_url: string;
      name: string;
      events: string[];
      active: boolean;
      config: {
        url?: string;
        insecure_ssl?: string;
        content_type?: string;
        secret?: string;
      };
      updated_at: string;
      created_at: string;
      type: string;
    };
    /** The URL to which the payloads will be delivered. */
    "webhook-config-url": string;
    /** The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. */
    "webhook-config-content-type": string;
    /** If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#delivery-headers). */
    "webhook-config-secret": string;
    "webhook-config-insecure-ssl": string | number;
    /** A team's access to a repository. */
    "team-repository": {
      /** Unique identifier of the repository */
      id: number;
      node_id: string;
      /** The name of the repository. */
      name: string;
      full_name: string;
      license: components["schemas"]["nullable-license-simple"];
      forks: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
      };
      owner: components["schemas"]["nullable-simple-user"];
      /** Whether the repository is private or public. */
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      /** The default branch of the repository. */
      default_branch: string;
      open_issues_count: number;
      /** Whether this repository acts as a template that can be used to generate new repositories. */
      is_template?: boolean;
      topics?: string[];
      /** Whether issues are enabled. */
      has_issues: boolean;
      /** Whether projects are enabled. */
      has_projects: boolean;
      /** Whether the wiki is enabled. */
      has_wiki: boolean;
      has_pages: boolean;
      /** Whether downloads are enabled. */
      has_downloads: boolean;
      /** Whether the repository is archived. */
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string | null;
      created_at: string | null;
      updated_at: string | null;
      /** Whether to allow rebase merges for pull requests. */
      allow_rebase_merge?: boolean;
      template_repository?: components["schemas"]["nullable-repository"];
      temp_clone_token?: string;
      /** Whether to allow squash merges for pull requests. */
      allow_squash_merge?: boolean;
      /** Whether to delete head branches when pull requests are merged */
      delete_branch_on_merge?: boolean;
      /** Whether to allow merge commits for pull requests. */
      allow_merge_commit?: boolean;
      /** Whether to allow forking this repo */
      allow_forking?: boolean;
      subscribers_count?: number;
      network_count?: number;
      open_issues: number;
      watchers: number;
      master_branch?: string;
    };
    /** Full Repository */
    "full-repository": {
      id: number;
      node_id: string;
      name: string;
      full_name: string;
      owner: components["schemas"]["simple-user"];
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      default_branch: string;
      open_issues_count: number;
      is_template?: boolean;
      topics?: string[];
      has_issues: boolean;
      has_projects: boolean;
      has_wiki: boolean;
      has_pages: boolean;
      has_downloads: boolean;
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string;
      created_at: string;
      updated_at: string;
      permissions?: {
        admin: boolean;
        maintain?: boolean;
        push: boolean;
        triage?: boolean;
        pull: boolean;
      };
      allow_rebase_merge?: boolean;
      template_repository?: components["schemas"]["nullable-repository"];
      temp_clone_token?: string | null;
      allow_squash_merge?: boolean;
      delete_branch_on_merge?: boolean;
      allow_merge_commit?: boolean;
      allow_forking?: boolean;
      subscribers_count: number;
      network_count: number;
      license: components["schemas"]["nullable-license-simple"];
      organization?: components["schemas"]["nullable-simple-user"];
      parent?: components["schemas"]["repository"];
      source?: components["schemas"]["repository"];
      forks: number;
      master_branch?: string;
      open_issues: number;
      watchers: number;
      /** Whether anonymous git access is allowed. */
      anonymous_access_enabled?: boolean;
      code_of_conduct?: components["schemas"]["code-of-conduct-simple"];
    };
    /** An invocation of a workflow */
    "workflow-run": {
      /** The ID of the workflow run. */
      id: number;
      /** The name of the workflow run. */
      name?: string | null;
      node_id: string;
      /** The ID of the associated check suite. */
      check_suite_id?: number;
      /** The node ID of the associated check suite. */
      check_suite_node_id?: string;
      head_branch: string | null;
      /** The SHA of the head commit that points to the version of the worflow being run. */
      head_sha: string;
      /** The auto incrementing run number for the workflow run. */
      run_number: number;
      event: string;
      status: string | null;
      conclusion: string | null;
      /** The ID of the parent workflow. */
      workflow_id: number;
      /** The URL to the workflow run. */
      url: string;
      html_url: string;
      pull_requests: components["schemas"]["pull-request-minimal"][] | null;
      created_at: string;
      updated_at: string;
      /** The URL to the jobs for the workflow run. */
      jobs_url: string;
      /** The URL to download the logs for the workflow run. */
      logs_url: string;
      /** The URL to the associated check suite. */
      check_suite_url: string;
      /** The URL to the artifacts for the workflow run. */
      artifacts_url: string;
      /** The URL to cancel the workflow run. */
      cancel_url: string;
      /** The URL to rerun the workflow run. */
      rerun_url: string;
      /** The URL to the workflow. */
      workflow_url: string;
      head_commit: components["schemas"]["nullable-simple-commit"];
      repository: components["schemas"]["minimal-repository"];
      head_repository: components["schemas"]["minimal-repository"];
      head_repository_id?: number;
    };
    /** A suite of checks performed on the code of a given code change */
    "check-suite": {
      id: number;
      node_id: string;
      head_branch: string | null;
      /** The SHA of the head commit that is being checked. */
      head_sha: string;
      status: ("queued" | "in_progress" | "completed") | null;
      conclusion:
        | (
            | "success"
            | "failure"
            | "neutral"
            | "cancelled"
            | "skipped"
            | "timed_out"
            | "action_required"
          )
        | null;
      url: string | null;
      before: string | null;
      after: string | null;
      pull_requests: components["schemas"]["pull-request-minimal"][] | null;
      app: components["schemas"]["nullable-integration"];
      repository: components["schemas"]["minimal-repository"];
      created_at: string | null;
      updated_at: string | null;
      head_commit: components["schemas"]["simple-commit"];
      latest_check_runs_count: number;
      check_runs_url: string;
    };
    /** Check suite configuration preferences for a repository. */
    "check-suite-preference": {
      preferences: {
        auto_trigger_checks?: {
          app_id: number;
          setting: boolean;
        }[];
      };
      repository: components["schemas"]["minimal-repository"];
    };
    "code-scanning-alert": {
      number: components["schemas"]["alert-number"];
      created_at: components["schemas"]["alert-created-at"];
      url: components["schemas"]["alert-url"];
      html_url: components["schemas"]["alert-html-url"];
      instances?: { [key: string]: unknown };
      instances_url: components["schemas"]["alert-instances-url"];
      state: components["schemas"]["code-scanning-alert-state"];
      dismissed_by: components["schemas"]["nullable-simple-user"];
      dismissed_at: components["schemas"]["code-scanning-alert-dismissed-at"];
      dismissed_reason: components["schemas"]["code-scanning-alert-dismissed-reason"];
      rule: components["schemas"]["code-scanning-alert-rule"];
      tool: components["schemas"]["code-scanning-analysis-tool"];
      most_recent_instance: components["schemas"]["code-scanning-alert-instance"];
    };
    /** Sets the state of the code scanning alert. Can be one of `open` or `dismissed`. You must provide `dismissed_reason` when you set the state to `dismissed`. */
    "code-scanning-alert-set-state": "open" | "dismissed";
    /** **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`. */
    "code-scanning-alert-dismissed-reason":
      | ("false positive" | "won't fix" | "used in tests")
      | null;
    /** Repository invitations let you manage who you collaborate with. */
    "repository-invitation": {
      /** Unique identifier of the repository invitation. */
      id: number;
      repository: components["schemas"]["minimal-repository"];
      invitee: components["schemas"]["nullable-simple-user"];
      inviter: components["schemas"]["nullable-simple-user"];
      /** The permission associated with the invitation. */
      permissions: "read" | "write" | "admin" | "triage" | "maintain";
      created_at: string;
      /** Whether or not the invitation has expired */
      expired?: boolean;
      /** URL for the repository invitation */
      url: string;
      html_url: string;
      node_id: string;
    };
    /** Pull Request Simple */
    "pull-request-simple": {
      url: string;
      id: number;
      node_id: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
      issue_url: string;
      commits_url: string;
      review_comments_url: string;
      review_comment_url: string;
      comments_url: string;
      statuses_url: string;
      number: number;
      state: string;
      locked: boolean;
      title: string;
      user: components["schemas"]["nullable-simple-user"];
      body: string | null;
      labels: {
        id?: number;
        node_id?: string;
        url?: string;
        name?: string;
        description?: string;
        color?: string;
        default?: boolean;
      }[];
      milestone: components["schemas"]["nullable-milestone"];
      active_lock_reason?: string | null;
      created_at: string;
      updated_at: string;
      closed_at: string | null;
      merged_at: string | null;
      merge_commit_sha: string | null;
      assignee: components["schemas"]["nullable-simple-user"];
      assignees?: components["schemas"]["simple-user"][] | null;
      requested_reviewers?: components["schemas"]["simple-user"][] | null;
      requested_teams?: components["schemas"]["team"][] | null;
      head: {
        label: string;
        ref: string;
        repo: components["schemas"]["repository"];
        sha: string;
        user: components["schemas"]["nullable-simple-user"];
      };
      base: {
        label: string;
        ref: string;
        repo: components["schemas"]["repository"];
        sha: string;
        user: components["schemas"]["nullable-simple-user"];
      };
      _links: {
        comments: components["schemas"]["link"];
        commits: components["schemas"]["link"];
        statuses: components["schemas"]["link"];
        html: components["schemas"]["link"];
        issue: components["schemas"]["link"];
        review_comments: components["schemas"]["link"];
        review_comment: components["schemas"]["link"];
        self: components["schemas"]["link"];
      };
      author_association: components["schemas"]["author_association"];
      auto_merge: components["schemas"]["auto_merge"];
      /** Indicates whether or not the pull request is a draft. */
      draft?: boolean;
    };
    /** Combined Commit Status */
    "combined-commit-status": {
      state: string;
      statuses: components["schemas"]["simple-commit-status"][];
      sha: string;
      total_count: number;
      repository: components["schemas"]["minimal-repository"];
      commit_url: string;
      url: string;
    };
    /** Commit Comparison */
    "commit-comparison": {
      url: string;
      html_url: string;
      permalink_url: string;
      diff_url: string;
      patch_url: string;
      base_commit: components["schemas"]["commit"];
      merge_base_commit: components["schemas"]["commit"];
      status: "diverged" | "ahead" | "behind" | "identical";
      ahead_by: number;
      behind_by: number;
      total_commits: number;
      commits: components["schemas"]["commit"][];
      files?: components["schemas"]["diff-entry"][];
    };
    /** Webhooks for repositories. */
    hook: {
      type: string;
      /** Unique identifier of the webhook. */
      id: number;
      /** The name of a valid service, use 'web' for a webhook. */
      name: string;
      /** Determines whether the hook is actually triggered on pushes. */
      active: boolean;
      /** Determines what events the hook is triggered for. Default: ['push']. */
      events: string[];
      config: {
        email?: string;
        password?: string;
        room?: string;
        subdomain?: string;
        url?: components["schemas"]["webhook-config-url"];
        insecure_ssl?: components["schemas"]["webhook-config-insecure-ssl"];
        content_type?: components["schemas"]["webhook-config-content-type"];
        digest?: string;
        secret?: components["schemas"]["webhook-config-secret"];
        token?: string;
      };
      updated_at: string;
      created_at: string;
      url: string;
      test_url: string;
      ping_url: string;
      last_response: components["schemas"]["hook-response"];
    };
    /** Issue Simple */
    "issue-simple": {
      id: number;
      node_id: string;
      url: string;
      repository_url: string;
      labels_url: string;
      comments_url: string;
      events_url: string;
      html_url: string;
      number: number;
      state: string;
      title: string;
      body?: string;
      user: components["schemas"]["nullable-simple-user"];
      labels: components["schemas"]["label"][];
      assignee: components["schemas"]["nullable-simple-user"];
      assignees?: components["schemas"]["simple-user"][] | null;
      milestone: components["schemas"]["nullable-milestone"];
      locked: boolean;
      active_lock_reason?: string | null;
      comments: number;
      pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
      };
      closed_at: string | null;
      created_at: string;
      updated_at: string;
      author_association: components["schemas"]["author_association"];
      body_html?: string;
      body_text?: string;
      timeline_url?: string;
      repository?: components["schemas"]["repository"];
      performed_via_github_app?: components["schemas"]["nullable-integration"];
    };
    /** Issue Event */
    "issue-event": {
      id: number;
      node_id: string;
      url: string;
      actor: components["schemas"]["nullable-simple-user"];
      event: string;
      commit_id: string | null;
      commit_url: string | null;
      created_at: string;
      issue?: components["schemas"]["issue-simple"];
      label?: components["schemas"]["issue-event-label"];
      assignee?: components["schemas"]["nullable-simple-user"];
      assigner?: components["schemas"]["nullable-simple-user"];
      review_requester?: components["schemas"]["nullable-simple-user"];
      requested_reviewer?: components["schemas"]["nullable-simple-user"];
      requested_team?: components["schemas"]["team"];
      dismissed_review?: components["schemas"]["issue-event-dismissed-review"];
      milestone?: components["schemas"]["issue-event-milestone"];
      project_card?: components["schemas"]["issue-event-project-card"];
      rename?: components["schemas"]["issue-event-rename"];
      author_association?: components["schemas"]["author_association"];
      lock_reason?: string | null;
      performed_via_github_app?: components["schemas"]["nullable-integration"];
    };
    /** A release. */
    release: {
      url: string;
      html_url: string;
      assets_url: string;
      upload_url: string;
      tarball_url: string | null;
      zipball_url: string | null;
      id: number;
      node_id: string;
      /** The name of the tag. */
      tag_name: string;
      /** Specifies the commitish value that determines where the Git tag is created from. */
      target_commitish: string;
      name: string | null;
      body?: string | null;
      /** true to create a draft (unpublished) release, false to create a published one. */
      draft: boolean;
      /** Whether to identify the release as a prerelease or a full release. */
      prerelease: boolean;
      created_at: string;
      published_at: string | null;
      author: components["schemas"]["simple-user"];
      assets: components["schemas"]["release-asset"][];
      body_html?: string;
      body_text?: string;
      reactions?: components["schemas"]["reaction-rollup"];
    };
    /** Code Search Result Item */
    "code-search-result-item": {
      name: string;
      path: string;
      sha: string;
      url: string;
      git_url: string;
      html_url: string;
      repository: components["schemas"]["minimal-repository"];
      score: number;
      file_size?: number;
      language?: string | null;
      last_modified_at?: string;
      line_numbers?: string[];
      text_matches?: components["schemas"]["search-result-text-matches"];
    };
    /** Commit Search Result Item */
    "commit-search-result-item": {
      url: string;
      sha: string;
      html_url: string;
      comments_url: string;
      commit: {
        author: {
          name: string;
          email: string;
          date: string;
        };
        committer: components["schemas"]["nullable-git-user"];
        comment_count: number;
        message: string;
        tree: {
          sha: string;
          url: string;
        };
        url: string;
        verification?: components["schemas"]["verification"];
      };
      author: components["schemas"]["nullable-simple-user"];
      committer: components["schemas"]["nullable-git-user"];
      parents: {
        url?: string;
        html_url?: string;
        sha?: string;
      }[];
      repository: components["schemas"]["minimal-repository"];
      score: number;
      node_id: string;
      text_matches?: components["schemas"]["search-result-text-matches"];
    };
    /** Issue Search Result Item */
    "issue-search-result-item": {
      url: string;
      repository_url: string;
      labels_url: string;
      comments_url: string;
      events_url: string;
      html_url: string;
      id: number;
      node_id: string;
      number: number;
      title: string;
      locked: boolean;
      active_lock_reason?: string | null;
      assignees?: components["schemas"]["simple-user"][] | null;
      user: components["schemas"]["nullable-simple-user"];
      labels: {
        id?: number;
        node_id?: string;
        url?: string;
        name?: string;
        color?: string;
        default?: boolean;
        description?: string | null;
      }[];
      state: string;
      assignee: components["schemas"]["nullable-simple-user"];
      milestone: components["schemas"]["nullable-milestone"];
      comments: number;
      created_at: string;
      updated_at: string;
      closed_at: string | null;
      text_matches?: components["schemas"]["search-result-text-matches"];
      pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
      };
      body?: string;
      score: number;
      author_association: components["schemas"]["author_association"];
      draft?: boolean;
      repository?: components["schemas"]["repository"];
      body_html?: string;
      body_text?: string;
      timeline_url?: string;
      performed_via_github_app?: components["schemas"]["nullable-integration"];
    };
    /** Repo Search Result Item */
    "repo-search-result-item": {
      id: number;
      node_id: string;
      name: string;
      full_name: string;
      owner: components["schemas"]["nullable-simple-user"];
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      created_at: string;
      updated_at: string;
      pushed_at: string;
      homepage: string | null;
      size: number;
      stargazers_count: number;
      watchers_count: number;
      language: string | null;
      forks_count: number;
      open_issues_count: number;
      master_branch?: string;
      default_branch: string;
      score: number;
      forks_url: string;
      keys_url: string;
      collaborators_url: string;
      teams_url: string;
      hooks_url: string;
      issue_events_url: string;
      events_url: string;
      assignees_url: string;
      branches_url: string;
      tags_url: string;
      blobs_url: string;
      git_tags_url: string;
      git_refs_url: string;
      trees_url: string;
      statuses_url: string;
      languages_url: string;
      stargazers_url: string;
      contributors_url: string;
      subscribers_url: string;
      subscription_url: string;
      commits_url: string;
      git_commits_url: string;
      comments_url: string;
      issue_comment_url: string;
      contents_url: string;
      compare_url: string;
      merges_url: string;
      archive_url: string;
      downloads_url: string;
      issues_url: string;
      pulls_url: string;
      milestones_url: string;
      notifications_url: string;
      labels_url: string;
      releases_url: string;
      deployments_url: string;
      git_url: string;
      ssh_url: string;
      clone_url: string;
      svn_url: string;
      forks: number;
      open_issues: number;
      watchers: number;
      topics?: string[];
      mirror_url: string | null;
      has_issues: boolean;
      has_projects: boolean;
      has_pages: boolean;
      has_wiki: boolean;
      has_downloads: boolean;
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      license: components["schemas"]["nullable-license-simple"];
      permissions?: {
        admin: boolean;
        maintain?: boolean;
        push: boolean;
        triage?: boolean;
        pull: boolean;
      };
      text_matches?: components["schemas"]["search-result-text-matches"];
      temp_clone_token?: string;
      allow_merge_commit?: boolean;
      allow_squash_merge?: boolean;
      allow_rebase_merge?: boolean;
      delete_branch_on_merge?: boolean;
      allow_forking?: boolean;
    };
    /** Starred Repository */
    "starred-repository": {
      starred_at: string;
      repo: components["schemas"]["repository"];
    };
    /** Simple User */
    "nullable-simple-user": {
      name?: string | null;
      email?: string | null;
      login: string;
      id: number;
      node_id: string;
      avatar_url: string;
      gravatar_id: string | null;
      url: string;
      html_url: string;
      followers_url: string;
      following_url: string;
      gists_url: string;
      starred_url: string;
      subscriptions_url: string;
      organizations_url: string;
      repos_url: string;
      events_url: string;
      received_events_url: string;
      type: string;
      site_admin: boolean;
      starred_at?: string;
    } | null;
    "nullable-scoped-installation": {
      permissions: components["schemas"]["app-permissions"];
      /** Describe whether all repositories have been selected or there's a selection involved */
      repository_selection: "all" | "selected";
      single_file_name: string | null;
      has_multiple_single_files?: boolean;
      single_file_paths?: string[];
      repositories_url: string;
      account: components["schemas"]["simple-user"];
    } | null;
    /** Simple User */
    "simple-user": {
      name?: string | null;
      email?: string | null;
      login: string;
      id: number;
      node_id: string;
      avatar_url: string;
      gravatar_id: string | null;
      url: string;
      html_url: string;
      followers_url: string;
      following_url: string;
      gists_url: string;
      starred_url: string;
      subscriptions_url: string;
      organizations_url: string;
      repos_url: string;
      events_url: string;
      received_events_url: string;
      type: string;
      site_admin: boolean;
      starred_at?: string;
    };
    /** Basic Error */
    "basic-error": {
      message?: string;
      documentation_url?: string;
      url?: string;
      status?: string;
    };
    /** Validation Error */
    "validation-error": {
      message: string;
      documentation_url: string;
      errors?: {
        resource?: string;
        field?: string;
        message?: string;
        code: string;
        index?: number;
        value?: (string | null) | (number | null) | (string[] | null);
      }[];
    };
    /** Actor */
    actor: {
      id: number;
      login: string;
      display_login?: string;
      gravatar_id: string | null;
      url: string;
      avatar_url: string;
    };
    /** Comments provide a way for people to collaborate on an issue. */
    "issue-comment": {
      /** Unique identifier of the issue comment */
      id: number;
      node_id: string;
      /** URL for the issue comment */
      url: string;
      /** Contents of the issue comment */
      body?: string;
      body_text?: string;
      body_html?: string;
      html_url: string;
      user: components["schemas"]["nullable-simple-user"];
      created_at: string;
      updated_at: string;
      issue_url: string;
      author_association: components["schemas"]["author_association"];
      performed_via_github_app?: components["schemas"]["nullable-integration"];
      reactions?: components["schemas"]["reaction-rollup"];
    };
    /** How the author is associated with the repository. */
    author_association:
      | "COLLABORATOR"
      | "CONTRIBUTOR"
      | "FIRST_TIMER"
      | "FIRST_TIME_CONTRIBUTOR"
      | "MANNEQUIN"
      | "MEMBER"
      | "NONE"
      | "OWNER";
    /** GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub. */
    "nullable-integration": {
      /** Unique identifier of the GitHub app */
      id: number;
      /** The slug name of the GitHub app */
      slug?: string;
      node_id: string;
      owner: components["schemas"]["nullable-simple-user"];
      /** The name of the GitHub app */
      name: string;
      description: string | null;
      external_url: string;
      html_url: string;
      created_at: string;
      updated_at: string;
      /** The set of permissions for the GitHub app */
      permissions: {
        issues?: string;
        checks?: string;
        metadata?: string;
        contents?: string;
        deployments?: string;
      } & { [key: string]: string };
      /** The list of events for the GitHub app */
      events: string[];
      /** The number of installations associated with the GitHub app */
      installations_count?: number;
      client_id?: string;
      client_secret?: string;
      webhook_secret?: string | null;
      pem?: string;
    } | null;
    "reaction-rollup": {
      url: string;
      total_count: number;
      "+1": number;
      "-1": number;
      laugh: number;
      confused: number;
      heart: number;
      hooray: number;
      eyes: number;
      rocket: number;
    };
    /** License Simple */
    "nullable-license-simple": {
      key: string;
      name: string;
      url: string | null;
      spdx_id: string | null;
      node_id: string;
      html_url?: string;
    } | null;
    /** A collection of related issues and pull requests. */
    "nullable-milestone": {
      url: string;
      html_url: string;
      labels_url: string;
      id: number;
      node_id: string;
      /** The number of the milestone. */
      number: number;
      /** The state of the milestone. */
      state: "open" | "closed";
      /** The title of the milestone. */
      title: string;
      description: string | null;
      creator: components["schemas"]["nullable-simple-user"];
      open_issues: number;
      closed_issues: number;
      created_at: string;
      updated_at: string;
      closed_at: string | null;
      due_on: string | null;
    } | null;
    /** A git repository */
    "nullable-repository": {
      /** Unique identifier of the repository */
      id: number;
      node_id: string;
      /** The name of the repository. */
      name: string;
      full_name: string;
      license: components["schemas"]["nullable-license-simple"];
      organization?: components["schemas"]["nullable-simple-user"];
      forks: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
      };
      owner: components["schemas"]["simple-user"];
      /** Whether the repository is private or public. */
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      /** The default branch of the repository. */
      default_branch: string;
      open_issues_count: number;
      /** Whether this repository acts as a template that can be used to generate new repositories. */
      is_template?: boolean;
      topics?: string[];
      /** Whether issues are enabled. */
      has_issues: boolean;
      /** Whether projects are enabled. */
      has_projects: boolean;
      /** Whether the wiki is enabled. */
      has_wiki: boolean;
      has_pages: boolean;
      /** Whether downloads are enabled. */
      has_downloads: boolean;
      /** Whether the repository is archived. */
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string | null;
      created_at: string | null;
      updated_at: string | null;
      /** Whether to allow rebase merges for pull requests. */
      allow_rebase_merge?: boolean;
      template_repository?: {
        id?: number;
        node_id?: string;
        name?: string;
        full_name?: string;
        owner?: {
          login?: string;
          id?: number;
          node_id?: string;
          avatar_url?: string;
          gravatar_id?: string;
          url?: string;
          html_url?: string;
          followers_url?: string;
          following_url?: string;
          gists_url?: string;
          starred_url?: string;
          subscriptions_url?: string;
          organizations_url?: string;
          repos_url?: string;
          events_url?: string;
          received_events_url?: string;
          type?: string;
          site_admin?: boolean;
        };
        private?: boolean;
        html_url?: string;
        description?: string;
        fork?: boolean;
        url?: string;
        archive_url?: string;
        assignees_url?: string;
        blobs_url?: string;
        branches_url?: string;
        collaborators_url?: string;
        comments_url?: string;
        commits_url?: string;
        compare_url?: string;
        contents_url?: string;
        contributors_url?: string;
        deployments_url?: string;
        downloads_url?: string;
        events_url?: string;
        forks_url?: string;
        git_commits_url?: string;
        git_refs_url?: string;
        git_tags_url?: string;
        git_url?: string;
        issue_comment_url?: string;
        issue_events_url?: string;
        issues_url?: string;
        keys_url?: string;
        labels_url?: string;
        languages_url?: string;
        merges_url?: string;
        milestones_url?: string;
        notifications_url?: string;
        pulls_url?: string;
        releases_url?: string;
        ssh_url?: string;
        stargazers_url?: string;
        statuses_url?: string;
        subscribers_url?: string;
        subscription_url?: string;
        tags_url?: string;
        teams_url?: string;
        trees_url?: string;
        clone_url?: string;
        mirror_url?: string;
        hooks_url?: string;
        svn_url?: string;
        homepage?: string;
        language?: string;
        forks_count?: number;
        stargazers_count?: number;
        watchers_count?: number;
        size?: number;
        default_branch?: string;
        open_issues_count?: number;
        is_template?: boolean;
        topics?: string[];
        has_issues?: boolean;
        has_projects?: boolean;
        has_wiki?: boolean;
        has_pages?: boolean;
        has_downloads?: boolean;
        archived?: boolean;
        disabled?: boolean;
        visibility?: string;
        pushed_at?: string;
        created_at?: string;
        updated_at?: string;
        permissions?: {
          admin?: boolean;
          maintain?: boolean;
          push?: boolean;
          triage?: boolean;
          pull?: boolean;
        };
        allow_rebase_merge?: boolean;
        temp_clone_token?: string;
        allow_squash_merge?: boolean;
        delete_branch_on_merge?: boolean;
        allow_merge_commit?: boolean;
        subscribers_count?: number;
        network_count?: number;
      } | null;
      temp_clone_token?: string;
      /** Whether to allow squash merges for pull requests. */
      allow_squash_merge?: boolean;
      /** Whether to delete head branches when pull requests are merged */
      delete_branch_on_merge?: boolean;
      /** Whether to allow merge commits for pull requests. */
      allow_merge_commit?: boolean;
      /** Whether to allow forking this repo */
      allow_forking?: boolean;
      subscribers_count?: number;
      network_count?: number;
      open_issues: number;
      watchers: number;
      master_branch?: string;
      starred_at?: string;
    } | null;
    /** Code Of Conduct */
    "code-of-conduct": {
      key: string;
      name: string;
      url: string;
      body?: string;
      html_url: string | null;
    };
    /** Code of Conduct Simple */
    "code-of-conduct-simple": {
      url: string;
      key: string;
      name: string;
      html_url: string | null;
    };
    "pull-request-minimal": {
      id: number;
      number: number;
      url: string;
      head: {
        ref: string;
        sha: string;
        repo: {
          id: number;
          url: string;
          name: string;
        };
      };
      base: {
        ref: string;
        sha: string;
        repo: {
          id: number;
          url: string;
          name: string;
        };
      };
    };
    /** Simple Commit */
    "nullable-simple-commit": {
      id: string;
      tree_id: string;
      message: string;
      timestamp: string;
      author: {
        name: string;
        email: string;
      } | null;
      committer: {
        name: string;
        email: string;
      } | null;
    } | null;
    /** Simple Commit */
    "simple-commit": {
      id: string;
      tree_id: string;
      message: string;
      timestamp: string;
      author: {
        name: string;
        email: string;
      } | null;
      committer: {
        name: string;
        email: string;
      } | null;
    };
    /** The security alert number. */
    "alert-number": number;
    /** The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
    "alert-created-at": string;
    /** The REST API URL of the alert resource. */
    "alert-url": string;
    /** The GitHub URL of the alert resource. */
    "alert-html-url": string;
    /** The REST API URL for fetching the list of instances for an alert. */
    "alert-instances-url": string;
    /** State of a code scanning alert. */
    "code-scanning-alert-state": "open" | "closed" | "dismissed" | "fixed";
    /** The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
    "code-scanning-alert-dismissed-at": string | null;
    "code-scanning-alert-rule": {
      /** A unique identifier for the rule used to detect the alert. */
      id?: string | null;
      /** The name of the rule used to detect the alert. */
      name?: string;
      /** The severity of the alert. */
      severity?: ("none" | "note" | "warning" | "error") | null;
      /** A short description of the rule used to detect the alert. */
      description?: string;
      /** description of the rule used to detect the alert. */
      full_description?: string;
      /** A set of tags applicable for the rule. */
      tags?: string[] | null;
      /** Detailed documentation for the rule as GitHub Flavored Markdown. */
      help?: string | null;
    };
    "code-scanning-analysis-tool": {
      name?: components["schemas"]["code-scanning-analysis-tool-name"];
      version?: components["schemas"]["code-scanning-analysis-tool-version"];
      guid?: components["schemas"]["code-scanning-analysis-tool-guid"];
    };
    /** The name of the tool used to generate the code scanning analysis. */
    "code-scanning-analysis-tool-name": string;
    /** The version of the tool used to generate the code scanning analysis. */
    "code-scanning-analysis-tool-version": string | null;
    /** The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data. */
    "code-scanning-analysis-tool-guid": string | null;
    "code-scanning-alert-instance": {
      ref?: components["schemas"]["code-scanning-ref"];
      analysis_key?: components["schemas"]["code-scanning-analysis-analysis-key"];
      environment?: components["schemas"]["code-scanning-alert-environment"];
      state?: components["schemas"]["code-scanning-alert-state"];
      commit_sha?: string;
      message?: {
        text?: string;
      };
      location?: components["schemas"]["code-scanning-alert-location"];
      html_url?: string;
      /**
       * Classifications that have been applied to the file that triggered the alert.
       * For example identifying it as documentation, or a generated file.
       */
      classifications?: components["schemas"]["code-scanning-alert-classification"][];
    };
    /**
     * The full Git reference, formatted as `refs/heads/<branch name>`,
     * `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
     */
    "code-scanning-ref": string;
    /** Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name. */
    "code-scanning-analysis-analysis-key": string;
    /** Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed. */
    "code-scanning-alert-environment": string;
    /** Describe a region within a file for the alert. */
    "code-scanning-alert-location": {
      path?: string;
      start_line?: number;
      end_line?: number;
      start_column?: number;
      end_column?: number;
    };
    /** A classification of the file. For example to identify it as generated. */
    "code-scanning-alert-classification":
      | ("source" | "generated" | "test" | "library")
      | null;
    /** Groups of organization members that gives permissions on specified repositories. */
    team: {
      id: number;
      node_id: string;
      name: string;
      slug: string;
      description: string | null;
      privacy?: string;
      permission: string;
      permissions?: {
        pull: boolean;
        triage: boolean;
        push: boolean;
        maintain: boolean;
        admin: boolean;
      };
      url: string;
      html_url: string;
      members_url: string;
      repositories_url: string;
      parent: components["schemas"]["nullable-team-simple"];
    };
    /** Groups of organization members that gives permissions on specified repositories. */
    "nullable-team-simple": {
      /** Unique identifier of the team */
      id: number;
      node_id: string;
      /** URL for the team */
      url: string;
      members_url: string;
      /** Name of the team */
      name: string;
      /** Description of the team */
      description: string | null;
      /** Permission that the team will have for its repositories */
      permission: string;
      /** The level of privacy this team should have */
      privacy?: string;
      html_url: string;
      repositories_url: string;
      slug: string;
      /** Distinguished Name (DN) that team maps to within LDAP environment */
      ldap_dn?: string;
    } | null;
    /** Hypermedia Link */
    link: {
      href: string;
    };
    /** The status of auto merging a pull request. */
    auto_merge: {
      enabled_by: components["schemas"]["simple-user"];
      /** The merge method to use. */
      merge_method: "merge" | "squash" | "rebase";
      /** Title for the merge commit message. */
      commit_title: string;
      /** Commit message for the merge commit. */
      commit_message: string;
    } | null;
    "simple-commit-status": {
      description: string | null;
      id: number;
      node_id: string;
      state: string;
      context: string;
      target_url: string;
      required?: boolean | null;
      avatar_url: string | null;
      url: string;
      created_at: string;
      updated_at: string;
    };
    /** Commit */
    commit: {
      url: string;
      sha: string;
      node_id: string;
      html_url: string;
      comments_url: string;
      commit: {
        url: string;
        author: components["schemas"]["nullable-git-user"];
        committer: components["schemas"]["nullable-git-user"];
        message: string;
        comment_count: number;
        tree: {
          sha: string;
          url: string;
        };
        verification?: components["schemas"]["verification"];
      };
      author: components["schemas"]["nullable-simple-user"];
      committer: components["schemas"]["nullable-simple-user"];
      parents: {
        sha: string;
        url: string;
        html_url?: string;
      }[];
      stats?: {
        additions?: number;
        deletions?: number;
        total?: number;
      };
      files?: {
        filename?: string;
        additions?: number;
        deletions?: number;
        changes?: number;
        status?: string;
        raw_url?: string;
        blob_url?: string;
        patch?: string;
        sha?: string;
        contents_url?: string;
        previous_filename?: string;
      }[];
    };
    /** Metaproperties for Git author/committer information. */
    "nullable-git-user": {
      name?: string;
      email?: string;
      date?: string;
    } | null;
    verification: {
      verified: boolean;
      reason: string;
      payload: string | null;
      signature: string | null;
    };
    /** Diff Entry */
    "diff-entry": {
      sha: string;
      filename: string;
      status:
        | "added"
        | "removed"
        | "modified"
        | "renamed"
        | "copied"
        | "changed"
        | "unchanged";
      additions: number;
      deletions: number;
      changes: number;
      blob_url: string;
      raw_url: string;
      contents_url: string;
      patch?: string;
      previous_filename?: string;
    };
    /** Scim Error */
    "scim-error": {
      message?: string | null;
      documentation_url?: string | null;
      detail?: string | null;
      status?: number;
      scimType?: string | null;
      schemas?: string[];
    };
    "hook-response": {
      code: number | null;
      status: string | null;
      message: string | null;
    };
    /** Color-coded labels help you categorize and filter your issues (just like labels in Gmail). */
    label: {
      id: number;
      node_id: string;
      /** URL for the label */
      url: string;
      /** The name of the label. */
      name: string;
      description: string | null;
      /** 6-character hex code, without the leading #, identifying the color */
      color: string;
      default: boolean;
    };
    /** Issue Event Label */
    "issue-event-label": {
      name: string | null;
      color: string | null;
    };
    "issue-event-dismissed-review": {
      state: string;
      review_id: number;
      dismissal_message: string | null;
      dismissal_commit_id?: string | null;
    };
    /** Issue Event Milestone */
    "issue-event-milestone": {
      title: string;
    };
    /** Issue Event Project Card */
    "issue-event-project-card": {
      url: string;
      id: number;
      project_url: string;
      project_id: number;
      column_name: string;
      previous_column_name?: string;
    };
    /** Issue Event Rename */
    "issue-event-rename": {
      from: string;
      to: string;
    };
    /** Data related to a release. */
    "release-asset": {
      url: string;
      browser_download_url: string;
      id: number;
      node_id: string;
      /** The file name of the asset. */
      name: string;
      label: string | null;
      /** State of the release asset. */
      state: "uploaded" | "open";
      content_type: string;
      size: number;
      download_count: number;
      created_at: string;
      updated_at: string;
      uploader: components["schemas"]["nullable-simple-user"];
    };
    "search-result-text-matches": {
      object_url?: string;
      object_type?: string | null;
      property?: string;
      fragment?: string;
      matches?: {
        text?: string;
        indices?: number[];
      }[];
    }[];
  };
  responses: {
    /** Requires authentication */
    requires_authentication: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Forbidden */
    forbidden: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Resource not found */
    not_found: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Preview header missing */
    preview_header_missing: {
      content: {
        "application/json": {
          message: string;
          documentation_url: string;
        };
      };
    };
    /** Validation failed */
    validation_failed: {
      content: {
        "application/json": components["schemas"]["validation-error"];
      };
    };
    /** Not modified */
    not_modified: unknown;
    /** Gone */
    gone: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Service unavailable */
    service_unavailable: {
      content: {
        "application/json": {
          code?: string;
          message?: string;
          documentation_url?: string;
        };
      };
    };
    /** Moved permanently */
    moved_permanently: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Temporary Redirect */
    temporary_redirect: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Response if GitHub Advanced Security is not enabled for this repository */
    code_scanning_forbidden_read: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Response if the repository is archived or if github advanced security is not enabled for this repository */
    code_scanning_forbidden_write: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Internal Error */
    internal_error: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Bad Request */
    bad_request: {
      content: {
        "application/json": components["schemas"]["basic-error"];
        "application/scim+json": components["schemas"]["scim-error"];
      };
    };
  };
  parameters: {
    /** Results per page (max 100) */
    "per-page": number;
    /** Page number of the results to fetch. */
    page: number;
    username: string;
    /** installation_id parameter */
    "installation-id": number;
    /** The client ID of your GitHub app. */
    "client-id": string;
    "access-token": string;
    /** authorization_id parameter */
    "authorization-id": number;
    /** The slug version of the enterprise name. You can also substitute this value with the enterprise id. */
    enterprise: string;
    /** A list of comma separated label names. Example: `bug,ui,@high` */
    labels: string;
    /** One of `asc` (ascending) or `desc` (descending). */
    direction: "asc" | "desc";
    /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
    since: string;
    owner: string;
    repo: string;
    /** If `true`, show notifications marked as read. */
    all: boolean;
    /** If `true`, only shows notifications in which the user is directly participating or mentioned. */
    participating: boolean;
    /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
    before: string;
    /** thread_id parameter */
    "thread-id": number;
    org: string;
    /** Unique identifier of the self-hosted runner group. */
    "runner-group-id": number;
    /** secret_name parameter */
    "secret-name": string;
    "hook-id": number;
    /** team_slug parameter */
    "team-slug": string;
    /** Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run. */
    actor: string;
    /** Returns workflow runs associated with a branch. Use the name of the branch of the `push`. */
    "workflow-run-branch": string;
    /** Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)." */
    event: string;
    /** Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see "[Create a check run](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#create-a-check-run)." */
    "workflow-run-status":
      | "completed"
      | "action_required"
      | "cancelled"
      | "failure"
      | "neutral"
      | "skipped"
      | "stale"
      | "success"
      | "timed_out"
      | "in_progress"
      | "queued"
      | "requested"
      | "waiting";
    created: string;
    /** The id of the workflow run. */
    "run-id": number;
    /** The ID of the workflow. You can also pass the workflow file name as a string. */
    "workflow-id": number | string;
    /** check_suite_id parameter */
    "check-suite-id": number;
    /** The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation. */
    "alert-number": components["schemas"]["alert-number"];
    /** commit_sha parameter */
    "commit-sha": string;
    /** Returns check runs with the specified `name`. */
    "check-name": string;
    /** invitation_id parameter */
    "invitation-id": number;
    /** issue_number parameter */
    "issue-number": number;
    "pull-number": number;
    /** release_id parameter */
    "release-id": number;
    /** A repository ID. Only return repositories with an ID greater than this ID. */
    "since-repo": number;
    /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
    order: "desc" | "asc";
    "team-id": number;
    /** One of `created` (when the repository was starred) or `updated` (when it was last pushed to). */
    sort: "created" | "updated";
  };
  headers: {
    link?: string;
  };
}

export interface operations {
  /** Lists personal access tokens for all users, including admin users. */
  "enterprise-admin/list-personal-access-tokens": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["authorization"][];
        };
      };
    };
  };
  "enterprise-admin/create-impersonation-o-auth-token": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** A list of [scopes](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). */
          scopes?: string[];
        };
      };
    };
  };
  /**
   * Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
   *
   * You must use a [JWT](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
   */
  "apps/create-installation-access-token": {
    parameters: {
      path: {
        /** installation_id parameter */
        installation_id: components["parameters"]["installation-id"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["installation-token"];
        };
      };
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      415: components["responses"]["preview_header_missing"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** List of repository names that the token should have access to */
          repositories?: string[];
          /** List of repository IDs that the token should have access to */
          repository_ids?: number[];
          permissions?: components["schemas"]["app-permissions"];
        };
      };
    };
  };
  /** OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) to use this endpoint, where the username is the OAuth application `client_id` and the password is its `client_secret`. Invalid tokens will return `404 NOT FOUND`. */
  "apps/check-token": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The access_token of the OAuth application. */
          access_token: string;
        };
      };
    };
  };
  /** OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`. */
  "apps/reset-token": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The access_token of the OAuth application. */
          access_token: string;
        };
      };
    };
  };
  /** Use a non-scoped user-to-server OAuth access token to create a repository scoped and/or permission scoped user-to-server OAuth access token. You can specify which repositories the token can access and which permissions are granted to the token. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`. */
  "apps/scope-token": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The OAuth access token used to authenticate to the GitHub API. */
          access_token: string;
          /** The name of the user or organization to scope the user-to-server access token to. **Required** unless `target_id` is specified. */
          target?: string;
          /** The ID of the user or organization to scope the user-to-server access token to. **Required** unless `target` is specified. */
          target_id?: number;
          /** The list of repository names to scope the user-to-server access token to. `repositories` may not be specified if `repository_ids` is specified. */
          repositories?: string[];
          /** The list of repository IDs to scope the user-to-server access token to. `repository_ids` may not be specified if `repositories` is specified. */
          repository_ids?: number[];
          permissions?: components["schemas"]["app-permissions"];
        };
      };
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
   *
   * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
   */
  "apps/check-authorization": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        access_token: components["parameters"]["access-token"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["nullable-authorization"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
   *
   * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
   */
  "apps/reset-authorization": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        access_token: components["parameters"]["access-token"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
    };
  };
  /** **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/). */
  "oauth-authorizations/list-authorizations": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** The client ID of your GitHub app. */
        client_id?: string;
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["authorization"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
   *
   * **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
   *
   * Creates OAuth tokens using [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication). If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
   *
   * To create tokens for a particular OAuth application using this endpoint, you must authenticate as the user you want to create an authorization for and provide the app's client ID and secret, found on your OAuth application's settings page. If your OAuth application intends to create multiple tokens for one user, use `fingerprint` to differentiate between them.
   *
   * You can also create tokens on GitHub Enterprise Server from the [personal access tokens settings](https://github.com/settings/tokens) page. Read more about these tokens in [the GitHub Help documentation](https://help.github.com/articles/creating-an-access-token-for-command-line-use).
   *
   * Organizations that enforce SAML SSO require personal access tokens to be allowed. Read more about allowing tokens in [the GitHub Help documentation](https://help.github.com/articles/about-identity-and-access-management-with-saml-single-sign-on).
   */
  "oauth-authorizations/create-authorization": {
    parameters: {};
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      410: components["responses"]["gone"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** A list of scopes that this authorization is in. */
          scopes?: string[] | null;
          /** A note to remind you what the OAuth token is for. */
          note?: string;
          /** A URL to remind you what app the OAuth token is for. */
          note_url?: string;
          /** The OAuth app client key for which to create the token. */
          client_id?: string;
          /** The OAuth app client secret for which to create the token. */
          client_secret?: string;
          /** A unique string to distinguish an authorization from others created for the same client ID and user. */
          fingerprint?: string;
        };
      };
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
   *
   * **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
   *
   * Creates a new authorization for the specified OAuth application, only if an authorization for that application doesn't already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
   *
   * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
   *
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
   */
  "oauth-authorizations/get-or-create-authorization-for-app": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
      };
    };
    responses: {
      /** if returning an existing token */
      200: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      /** **Deprecation Notice:** GitHub will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/). */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The OAuth app client secret for which to create the token. */
          client_secret: string;
          /** A list of scopes that this authorization is in. */
          scopes?: string[] | null;
          /** A note to remind you what the OAuth token is for. */
          note?: string;
          /** A URL to remind you what app the OAuth token is for. */
          note_url?: string;
          /** A unique string to distinguish an authorization from others created for the same client ID and user. */
          fingerprint?: string;
        };
      };
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
   *
   * **Warning:** Apps must use the [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow) to obtain OAuth tokens that work with GitHub Enterprise Server SAML organizations. OAuth tokens created using the Authorizations API will be unable to access GitHub Enterprise Server SAML organizations. For more information, see the [blog post](https://developer.github.com/changes/2019-11-05-deprecated-passwords-and-authorizations-api).
   *
   * This method will create a new authorization for the specified OAuth application, only if an authorization for that application and fingerprint do not already exist for the user. The URL includes the 20 character client ID for the OAuth app that is requesting the token. `fingerprint` is a unique string to distinguish an authorization from others created for the same client ID and user. It returns the user's existing authorization for the application if one is present. Otherwise, it creates and returns a new one.
   *
   * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
   */
  "oauth-authorizations/get-or-create-authorization-for-app-and-fingerprint": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        fingerprint: string;
      };
    };
    responses: {
      /** if returning an existing token */
      200: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      /** Response if returning a new token */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The OAuth app client secret for which to create the token. */
          client_secret: string;
          /** A list of scopes that this authorization is in. */
          scopes?: string[] | null;
          /** A note to remind you what the OAuth token is for. */
          note?: string;
          /** A URL to remind you what app the OAuth token is for. */
          note_url?: string;
        };
      };
    };
  };
  /** **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/). */
  "oauth-authorizations/get-authorization": {
    parameters: {
      path: {
        /** authorization_id parameter */
        authorization_id: components["parameters"]["authorization-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue the [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations/), which is used by integrations to create personal access tokens and OAuth tokens, and you must now create these tokens using our [web application flow](https://docs.github.com/enterprise-server@3.1/developers/apps/authorizing-oauth-apps#web-application-flow). The [OAuth Authorizations API](https://docs.github.com/enterprise-server@3.1/rest/reference/oauth-authorizations) will be removed on November, 13, 2020. For more information, including scheduled brownouts, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/).
   *
   * If you have two-factor authentication setup, Basic Authentication for this endpoint requires that you use a one-time password (OTP) and your username and password instead of tokens. For more information, see "[Working with two-factor authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#working-with-two-factor-authentication)."
   *
   * You can only send one of these scope keys at a time.
   */
  "oauth-authorizations/update-authorization": {
    parameters: {
      path: {
        /** authorization_id parameter */
        authorization_id: components["parameters"]["authorization-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** A list of scopes that this authorization is in. */
          scopes?: string[] | null;
          /** A list of scopes to add to this authorization. */
          add_scopes?: string[];
          /** A list of scopes to remove from this authorization. */
          remove_scopes?: string[];
          /** A note to remind you what the OAuth token is for. */
          note?: string;
          /** A URL to remind you what app the OAuth token is for. */
          note_url?: string;
          /** A unique string to distinguish an authorization from others created for the same client ID and user. */
          fingerprint?: string;
        };
      };
    };
  };
  /**
   * Returns a token that you can pass to the `config` script. The token expires after one hour.
   *
   * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
   *
   * #### Example using registration token
   *
   * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
   *
   * ```
   * ./config.sh --url https://github.com/enterprises/octo-enterprise --token TOKEN
   * ```
   */
  "enterprise-admin/create-registration-token-for-enterprise": {
    parameters: {
      path: {
        /** The slug version of the enterprise name. You can also substitute this value with the enterprise id. */
        enterprise: components["parameters"]["enterprise"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authentication-token"];
        };
      };
    };
  };
  /**
   * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an enterprise. The token expires after one hour.
   *
   * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
   *
   * #### Example using remove token
   *
   * To remove your self-hosted runner from an enterprise, replace `TOKEN` with the remove token provided by this
   * endpoint.
   *
   * ```
   * ./config.sh remove --token TOKEN
   * ```
   */
  "enterprise-admin/create-remove-token-for-enterprise": {
    parameters: {
      path: {
        /** The slug version of the enterprise name. You can also substitute this value with the enterprise id. */
        enterprise: components["parameters"]["enterprise"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authentication-token"];
        };
      };
    };
  };
  /** We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago. */
  "activity/list-public-events": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /**
   * List repositories that an app installation can access.
   *
   * You must use an [installation access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
   */
  "apps/list-repos-accessible-to-installation": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            repositories: components["schemas"]["repository"][];
            repository_selection?: string;
          };
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /**
   * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
   * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
   * necessarily assigned to you.
   *
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list": {
    parameters: {
      query: {
        /**
         * Indicates which sorts of issues to return. Can be one of:
         * \* `assigned`: Issues assigned to you
         * \* `created`: Issues created by you
         * \* `mentioned`: Issues mentioning you
         * \* `subscribed`: Issues you're subscribed to updates for
         * \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
         */
        filter?:
          | "assigned"
          | "created"
          | "mentioned"
          | "subscribed"
          | "repos"
          | "all";
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        collab?: boolean;
        orgs?: boolean;
        owned?: boolean;
        pulls?: boolean;
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue"][];
        };
      };
      304: components["responses"]["not_modified"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
  };
  "activity/list-public-events-for-repo-network": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
      301: components["responses"]["moved_permanently"];
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /** List all notifications for the current user, sorted by most recently updated. */
  "activity/list-notifications-for-authenticated-user": {
    parameters: {
      query: {
        /** If `true`, show notifications marked as read. */
        all?: components["parameters"]["all"];
        /** If `true`, only shows notifications in which the user is directly participating or mentioned. */
        participating?: components["parameters"]["participating"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        before?: components["parameters"]["before"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["thread"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
    };
  };
  "activity/get-thread": {
    parameters: {
      path: {
        /** thread_id parameter */
        thread_id: components["parameters"]["thread-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["thread"];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /**
   * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
   *
   * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
   */
  "actions/list-selected-repositories-enabled-github-actions-organization": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            repositories: components["schemas"]["repository"][];
          };
        };
      };
    };
  };
  /**
   * The self-hosted runner groups REST API is available with GitHub Enterprise Cloud and GitHub Enterprise Server. For more information, see "[GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products)."
   *
   * Lists the repositories with access to a self-hosted runner group configured in an organization.
   *
   * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
   */
  "actions/list-repo-access-to-self-hosted-runner-group-in-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** Unique identifier of the self-hosted runner group. */
        runner_group_id: components["parameters"]["runner-group-id"];
      };
      query: {
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            repositories: components["schemas"]["minimal-repository"][];
          };
        };
      };
    };
  };
  /**
   * Returns a token that you can pass to the `config` script. The token expires after one hour.
   *
   * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
   *
   * #### Example using registration token
   *
   * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
   *
   * ```
   * ./config.sh --url https://github.com/octo-org --token TOKEN
   * ```
   */
  "actions/create-registration-token-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authentication-token"];
        };
      };
    };
  };
  /**
   * Returns a token that you can pass to the `config` script to remove a self-hosted runner from an organization. The token expires after one hour.
   *
   * You must authenticate using an access token with the `admin:org` scope to use this endpoint.
   *
   * #### Example using remove token
   *
   * To remove your self-hosted runner from an organization, replace `TOKEN` with the remove token provided by this
   * endpoint.
   *
   * ```
   * ./config.sh remove --token TOKEN
   * ```
   */
  "actions/create-remove-token-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authentication-token"];
        };
      };
    };
  };
  /** Lists all repositories that have been selected when the `visibility` for repository access to a secret is set to `selected`. You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `secrets` organization permission to use this endpoint. */
  "actions/list-selected-repos-for-org-secret": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** secret_name parameter */
        secret_name: components["parameters"]["secret-name"];
      };
      query: {
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            repositories: components["schemas"]["minimal-repository"][];
          };
        };
      };
    };
  };
  "activity/list-public-org-events": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "orgs/list-webhooks": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["org-hook"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Here's how you can create a hook that posts payloads in JSON format: */
  "orgs/create-webhook": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
    };
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["org-hook"];
        };
      };
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** Must be passed as "web". */
          name: string;
          /** Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.1/rest/reference/orgs#create-hook-config-params). */
          config: {
            url: components["schemas"]["webhook-config-url"];
            content_type?: components["schemas"]["webhook-config-content-type"];
            secret?: components["schemas"]["webhook-config-secret"];
            insecure_ssl?: components["schemas"]["webhook-config-insecure-ssl"];
            username?: string;
            password?: string;
          };
          /** Determines what [events](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads) the hook is triggered for. */
          events?: string[];
          /** Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. */
          active?: boolean;
        };
      };
    };
  };
  /** Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)." */
  "orgs/get-webhook": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-hook"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Updates a webhook configured in an organization. When you update a webhook, the `secret` will be overwritten. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for an organization](/rest/reference/orgs#update-a-webhook-configuration-for-an-organization)." */
  "orgs/update-webhook": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-hook"];
        };
      };
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.1/rest/reference/orgs#update-hook-config-params). */
          config?: {
            url: components["schemas"]["webhook-config-url"];
            content_type?: components["schemas"]["webhook-config-content-type"];
            secret?: components["schemas"]["webhook-config-secret"];
            insecure_ssl?: components["schemas"]["webhook-config-insecure-ssl"];
          };
          /** Determines what [events](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads) the hook is triggered for. */
          events?: string[];
          /** Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. */
          active?: boolean;
          name?: string;
        };
      };
    };
  };
  /**
   * List issues in an organization assigned to the authenticated user.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /**
         * Indicates which sorts of issues to return. Can be one of:
         * \* `assigned`: Issues assigned to you
         * \* `created`: Issues created by you
         * \* `mentioned`: Issues mentioning you
         * \* `subscribed`: Issues you're subscribed to updates for
         * \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
         */
        filter?:
          | "assigned"
          | "created"
          | "mentioned"
          | "subscribed"
          | "repos"
          | "all";
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Lists repositories for the specified organization. */
  "repos/list-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Specifies the types of repositories you want returned. Can be one of `all`, `public`, `private`, `forks`, `sources`, `member`, `internal`. Note: For GitHub AE, can be one of `all`, `private`, `forks`, `sources`, `member`, `internal`. Default: `all`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `type` can also be `internal`. However, the `internal` value is not yet supported when a GitHub App calls this API with an installation access token. */
        type?:
          | "all"
          | "public"
          | "private"
          | "forks"
          | "sources"
          | "member"
          | "internal";
        /** Can be one of `created`, `updated`, `pushed`, `full_name`. */
        sort?: "created" | "updated" | "pushed" | "full_name";
        /** Can be one of `asc` or `desc`. Default: when using `full_name`: `asc`, otherwise `desc` */
        direction?: "asc" | "desc";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
    };
  };
  /**
   * Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
   *
   * **OAuth scope requirements**
   *
   * When using [OAuth](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
   *
   * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
   * *   `repo` scope to create a private repository
   */
  "repos/create-in-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
    };
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["repository"];
        };
      };
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the repository. */
          name: string;
          /** A short description of the repository. */
          description?: string;
          /** A URL with more information about the repository. */
          homepage?: string;
          /** Whether the repository is private. */
          private?: boolean;
          /**
           * Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.
           * The `visibility` parameter overrides the `private` parameter when you use both parameters with the `nebula-preview` preview header.
           */
          visibility?: "public" | "private" | "visibility" | "internal";
          /** Either `true` to enable issues for this repository or `false` to disable them. */
          has_issues?: boolean;
          /** Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error. */
          has_projects?: boolean;
          /** Either `true` to enable the wiki for this repository or `false` to disable it. */
          has_wiki?: boolean;
          /** Either `true` to make this repo available as a template repository or `false` to prevent it. */
          is_template?: boolean;
          /** The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization. */
          team_id?: number;
          /** Pass `true` to create an initial commit with empty README. */
          auto_init?: boolean;
          /** Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell". */
          gitignore_template?: string;
          /** Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://help.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0". */
          license_template?: string;
          /** Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging. */
          allow_squash_merge?: boolean;
          /** Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits. */
          allow_merge_commit?: boolean;
          /** Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging. */
          allow_rebase_merge?: boolean;
          /** Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. */
          delete_branch_on_merge?: boolean;
        };
      };
    };
  };
  /**
   * Lists a team's repositories visible to the authenticated user.
   *
   * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
   */
  "teams/list-repos-in-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** team_slug parameter */
        team_slug: components["parameters"]["team-slug"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
    };
  };
  /**
   * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
   *
   * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
   *
   * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
   *
   * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
   */
  "teams/check-permissions-for-repo-in-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** team_slug parameter */
        team_slug: components["parameters"]["team-slug"];
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Alternative response with repository permissions */
      200: {
        content: {
          "application/json": components["schemas"]["team-repository"];
        };
      };
      /** Response if team has permission for the repository. This is the response when the repository media type hasn't been provded in the Accept header. */
      204: never;
      /** Not Found if team does not have permission for the repository */
      404: unknown;
    };
  };
  /**
   * When you pass the `scarlet-witch-preview` media type, requests to get a repository will also return the repository's code of conduct if it can be detected from the repository's code of conduct file.
   *
   * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
   */
  "repos/get": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["full-repository"];
        };
      };
      301: components["responses"]["moved_permanently"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /** **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#replace-all-repository-topics) endpoint. */
  "repos/update": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["full-repository"];
        };
      };
      307: components["responses"]["temporary_redirect"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the repository. */
          name?: string;
          /** A short description of the repository. */
          description?: string;
          /** A URL with more information about the repository. */
          homepage?: string;
          /**
           * Either `true` to make the repository private or `false` to make it public. Default: `false`.
           * **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private. **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://help.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.
           */
          private?: boolean;
          /** Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. The `visibility` parameter overrides the `private` parameter when you use both along with the `nebula-preview` preview header. */
          visibility?: "public" | "private" | "visibility" | "internal";
          /** Either `true` to enable issues for this repository or `false` to disable them. */
          has_issues?: boolean;
          /** Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error. */
          has_projects?: boolean;
          /** Either `true` to enable the wiki for this repository or `false` to disable it. */
          has_wiki?: boolean;
          /** Either `true` to make this repo available as a template repository or `false` to prevent it. */
          is_template?: boolean;
          /** Updates the default branch for this repository. */
          default_branch?: string;
          /** Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging. */
          allow_squash_merge?: boolean;
          /** Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits. */
          allow_merge_commit?: boolean;
          /** Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging. */
          allow_rebase_merge?: boolean;
          /** Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. */
          delete_branch_on_merge?: boolean;
          /** `true` to archive this repository. **Note**: You cannot unarchive repositories through the API. */
          archived?: boolean;
          /** Either `true` to allow private forks, or `false` to prevent private forks. */
          allow_forking?: boolean;
        };
      };
    };
  };
  /**
   * Returns a token that you can pass to the `config` script. The token expires after one hour. You must authenticate
   * using an access token with the `repo` scope to use this endpoint.
   *
   * #### Example using registration token
   *
   * Configure your self-hosted runner, replacing `TOKEN` with the registration token provided by this endpoint.
   *
   * ```
   * ./config.sh --url https://github.com/octo-org/octo-repo-artifacts --token TOKEN
   * ```
   */
  "actions/create-registration-token-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authentication-token"];
        };
      };
    };
  };
  /**
   * Returns a token that you can pass to remove a self-hosted runner from a repository. The token expires after one hour.
   * You must authenticate using an access token with the `repo` scope to use this endpoint.
   *
   * #### Example using remove token
   *
   * To remove your self-hosted runner from a repository, replace TOKEN with the remove token provided by this endpoint.
   *
   * ```
   * ./config.sh remove --token TOKEN
   * ```
   */
  "actions/create-remove-token-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authentication-token"];
        };
      };
    };
  };
  /**
   * Lists all workflow runs for a repository. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#parameters).
   *
   * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint.
   */
  "actions/list-workflow-runs-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run. */
        actor?: components["parameters"]["actor"];
        /** Returns workflow runs associated with a branch. Use the name of the branch of the `push`. */
        branch?: components["parameters"]["workflow-run-branch"];
        /** Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)." */
        event?: components["parameters"]["event"];
        /** Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see "[Create a check run](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#create-a-check-run)." */
        status?: components["parameters"]["workflow-run-status"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        created?: components["parameters"]["created"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            workflow_runs: components["schemas"]["workflow-run"][];
          };
        };
      };
    };
  };
  /** Gets a specific workflow run. Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope. GitHub Apps must have the `actions:read` permission to use this endpoint. */
  "actions/get-workflow-run": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The id of the workflow run. */
        run_id: components["parameters"]["run-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["workflow-run"];
        };
      };
    };
  };
  /**
   * List all workflow runs for a workflow. You can replace `workflow_id` with the workflow file name. For example, you could use `main.yaml`. You can use parameters to narrow the list of results. For more information about using parameters, see [Parameters](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#parameters).
   *
   * Anyone with read access to the repository can use this endpoint. If the repository is private you must use an access token with the `repo` scope.
   */
  "actions/list-workflow-runs": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The ID of the workflow. You can also pass the workflow file name as a string. */
        workflow_id: components["parameters"]["workflow-id"];
      };
      query: {
        /** Returns someone's workflow runs. Use the login for the user who created the `push` associated with the check suite or workflow run. */
        actor?: components["parameters"]["actor"];
        /** Returns workflow runs associated with a branch. Use the name of the branch of the `push`. */
        branch?: components["parameters"]["workflow-run-branch"];
        /** Returns workflow run triggered by the event you specify. For example, `push`, `pull_request` or `issue`. For more information, see "[Events that trigger workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)." */
        event?: components["parameters"]["event"];
        /** Returns workflow runs with the check run `status` or `conclusion` that you specify. For example, a conclusion can be `success` or a status can be `in_progress`. Only GitHub can set a status of `waiting` or `requested`. For a list of the possible `status` and `conclusion` options, see "[Create a check run](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#create-a-check-run)." */
        status?: components["parameters"]["workflow-run-status"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        created?: components["parameters"]["created"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            workflow_runs: components["schemas"]["workflow-run"][];
          };
        };
      };
    };
  };
  /**
   * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
   *
   * By default, check suites are automatically created when you create a [check run](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#check-runs). You only need to use this endpoint for manually creating check suites when you've disabled automatic creation using "[Update repository preferences for check suites](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#update-repository-preferences-for-check-suites)". Your GitHub App must have the `checks:write` permission to create check suites.
   */
  "checks/create-suite": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** when the suite already existed */
      200: {
        content: {
          "application/json": components["schemas"]["check-suite"];
        };
      };
      /** Response when the suite was created */
      201: {
        content: {
          "application/json": components["schemas"]["check-suite"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The sha of the head commit. */
          head_sha: string;
        };
      };
    };
  };
  /** Changes the default automatic flow when creating check suites. By default, a check suite is automatically created each time code is pushed to a repository. When you disable the automatic creation of check suites, you can manually [Create a check suite](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#create-a-check-suite). You must have admin permissions in the repository to set preferences for check suites. */
  "checks/set-suites-preferences": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["check-suite-preference"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default. See the [`auto_trigger_checks` object](https://docs.github.com/enterprise-server@3.1/rest/reference/checks#auto_trigger_checks-object) description for details. */
          auto_trigger_checks?: {
            /** The `id` of the GitHub App. */
            app_id: number;
            /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them. */
            setting: boolean;
          }[];
        };
      };
    };
  };
  /**
   * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
   *
   * Gets a single check suite using its `id`. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to get check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
   */
  "checks/get-suite": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** check_suite_id parameter */
        check_suite_id: components["parameters"]["check-suite-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["check-suite"];
        };
      };
    };
  };
  /**
   * Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
   *
   * **Deprecation notice**:
   * The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
   */
  "code-scanning/get-alert": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation. */
        alert_number: components["parameters"]["alert-number"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["code-scanning-alert"];
        };
      };
      403: components["responses"]["code_scanning_forbidden_read"];
      404: components["responses"]["not_found"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /** Updates the status of a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` write permission to use this endpoint. */
  "code-scanning/update-alert": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation. */
        alert_number: components["parameters"]["alert-number"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["code-scanning-alert"];
        };
      };
      403: components["responses"]["code_scanning_forbidden_write"];
      404: components["responses"]["not_found"];
      503: components["responses"]["service_unavailable"];
    };
    requestBody: {
      content: {
        "application/json": {
          state: components["schemas"]["code-scanning-alert-set-state"];
          dismissed_reason?: components["schemas"]["code-scanning-alert-dismissed-reason"];
        };
      };
    };
  };
  /**
   * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
   *
   * For more information the permission levels, see "[Repository permission levels for an organization](https://help.github.com/en/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
   *
   * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-verbs)."
   *
   * The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [repository invitations API endpoints](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#invitations).
   *
   * **Rate limits**
   *
   * You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
   */
  "repos/add-collaborator": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response when a new invitation is created */
      201: {
        content: {
          "application/json": components["schemas"]["repository-invitation"];
        };
      };
      /** Response when person is already a collaborator */
      204: never;
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /**
           * The permission to grant the collaborator. **Only valid on organization-owned repositories.** Can be one of:
           * \* `pull` - can pull, but not push to or administer this repository.
           * \* `push` - can pull and push, but not administer this repository.
           * \* `admin` - can pull, push and administer this repository.
           * \* `maintain` - Recommended for project managers who need to manage the repository without access to sensitive or destructive actions.
           * \* `triage` - Recommended for contributors who need to proactively manage issues and pull requests without write access.
           */
          permission?: "pull" | "push" | "admin" | "maintain" | "triage";
          permissions?: string;
        };
      };
    };
  };
  /** Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. Additional preview headers may be required to see certain details for associated pull requests, such as whether a pull request is in a draft state. For more information about previews that might affect this endpoint, see the [List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests) endpoint. */
  "repos/list-pull-requests-associated-with-commit": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** commit_sha parameter */
        commit_sha: components["parameters"]["commit-sha"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["pull-request-simple"][];
        };
      };
      415: components["responses"]["preview_header_missing"];
    };
  };
  /**
   * **Note:** The Checks API only looks for pushes in the repository where the check suite or check run were created. Pushes to a branch in a forked repository are not detected and return an empty `pull_requests` array and a `null` value for `head_branch`.
   *
   * Lists check suites for a commit `ref`. The `ref` can be a SHA, branch name, or a tag name. GitHub Apps must have the `checks:read` permission on a private repository or pull access to a public repository to list check suites. OAuth Apps and authenticated users must have the `repo` scope to get check suites in a private repository.
   */
  "checks/list-suites-for-ref": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** ref parameter */
        ref: string;
      };
      query: {
        /** Filters check suites by GitHub App `id`. */
        app_id?: number;
        /** Returns check runs with the specified `name`. */
        check_name?: components["parameters"]["check-name"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            check_suites: components["schemas"]["check-suite"][];
          };
        };
      };
    };
  };
  /**
   * Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
   *
   * The most recent status for each context is returned, up to 100. This field [paginates](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination) if there are over 100 contexts.
   *
   * Additionally, a combined `state` is returned. The `state` is one of:
   *
   * *   **failure** if any of the contexts report as `error` or `failure`
   * *   **pending** if there are no statuses or a context is `pending`
   * *   **success** if the latest status for all contexts is `success`
   */
  "repos/get-combined-status-for-ref": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** ref parameter */
        ref: string;
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["combined-commit-status"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.
   *
   * The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
   *
   * The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
   *
   * **Working with large comparisons**
   *
   * The response will include a comparison of up to 250 commits. If you are working with a larger commit range, you can use the [List commits](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-commits) to enumerate all commits in the range.
   *
   * For comparisons with extremely large diffs, you may receive an error response indicating that the diff took too long
   * to generate. You can typically resolve this error by using a smaller commit range.
   *
   * **Signature verification object**
   *
   * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
   *
   * | Name | Type | Description |
   * | ---- | ---- | ----------- |
   * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
   * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
   * | `signature` | `string` | The signature that was extracted from the commit. |
   * | `payload` | `string` | The value that was signed. |
   *
   * These are the possible values for `reason` in the `verification` object:
   *
   * | Value | Description |
   * | ----- | ----------- |
   * | `expired_key` | The key that made the signature is expired. |
   * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
   * | `gpgverify_error` | There was an error communicating with the signature verification service. |
   * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
   * | `unsigned` | The object does not include a signature. |
   * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
   * | `no_user` | No user was associated with the `committer` email address in the commit. |
   * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
   * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
   * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
   * | `malformed_signature` | There was an error parsing the signature. |
   * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
   * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
   */
  "repos/compare-commits-with-basehead": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The base branch and head branch to compare. This parameter expects the format `{base}...{head}`. */
        basehead: string;
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["commit-comparison"];
        };
      };
      404: components["responses"]["not_found"];
      500: components["responses"]["internal_error"];
    };
  };
  "activity/list-repo-events": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "repos/list-forks": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** The sort order. Can be either `newest`, `oldest`, or `stargazers`. */
        sort?: "newest" | "oldest" | "stargazers" | "watchers";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
      400: components["responses"]["bad_request"];
    };
  };
  /**
   * Create a fork for the authenticated user.
   *
   * **Note**: Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Enterprise Server Support](https://support.github.com/contact?tags=dotcom-rest-api).
   */
  "repos/create-fork": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      202: {
        content: {
          "application/json": components["schemas"]["full-repository"];
        };
      };
      400: components["responses"]["bad_request"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** Optional parameter to specify the organization name if forking into an organization. */
          organization?: string;
        } | null;
      };
    };
  };
  "repos/list-webhooks": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["hook"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
   * share the same `config` as long as those webhooks do not have any `events` that overlap.
   */
  "repos/create-webhook": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["hook"];
        };
      };
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`. */
          name?: string;
          /** Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#create-hook-config-params). */
          config?: {
            url?: components["schemas"]["webhook-config-url"];
            content_type?: components["schemas"]["webhook-config-content-type"];
            secret?: components["schemas"]["webhook-config-secret"];
            insecure_ssl?: components["schemas"]["webhook-config-insecure-ssl"];
            token?: string;
            digest?: string;
          };
          /** Determines what [events](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads) the hook is triggered for. */
          events?: string[];
          /** Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. */
          active?: boolean;
        } | null;
      };
    };
  };
  /** Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)." */
  "repos/get-webhook": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["hook"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/reference/repos#update-a-webhook-configuration-for-a-repository)." */
  "repos/update-webhook": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["hook"];
        };
      };
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#create-hook-config-params). */
          config?: {
            url: components["schemas"]["webhook-config-url"];
            content_type?: components["schemas"]["webhook-config-content-type"];
            secret?: components["schemas"]["webhook-config-secret"];
            insecure_ssl?: components["schemas"]["webhook-config-insecure-ssl"];
            address?: string;
            room?: string;
          };
          /** Determines what [events](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events. */
          events?: string[];
          /** Determines a list of events to be added to the list of events that the Hook triggers for. */
          add_events?: string[];
          /** Determines a list of events to be removed from the list of events that the Hook triggers for. */
          remove_events?: string[];
          /** Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. */
          active?: boolean;
        };
      };
    };
  };
  /** When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations. */
  "repos/list-invitations": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["repository-invitation"][];
        };
      };
    };
  };
  "repos/update-invitation": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** invitation_id parameter */
        invitation_id: components["parameters"]["invitation-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["repository-invitation"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`. */
          permissions?: "read" | "write" | "maintain" | "triage" | "admin";
        };
      };
    };
  };
  /**
   * List issues in a repository.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned. */
        milestone?: string;
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user. */
        assignee?: string;
        /** The user that created the issue. */
        creator?: string;
        /** A user that's mentioned in the issue. */
        mentioned?: string;
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue-simple"][];
        };
      };
      301: components["responses"]["moved_permanently"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
  };
  /**
   * Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://help.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
   *
   * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
   */
  "issues/create": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["issue"];
        };
      };
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      410: components["responses"]["gone"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The title of the issue. */
          title: string | number;
          /** The contents of the issue. */
          body?: string;
          /** Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is deprecated.**_ */
          assignee?: string | null;
          milestone?: (string | number) | null;
          /** Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._ */
          labels?: (
            | string
            | {
                id?: number;
                name?: string;
                description?: string | null;
                color?: string | null;
              }
          )[];
          /** Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._ */
          assignees?: string[];
        };
      };
    };
  };
  "issues/list-events-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue-event"][];
        };
      };
      422: components["responses"]["validation_failed"];
    };
  };
  "issues/get-event": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        event_id: number;
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["issue-event"];
        };
      };
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      410: components["responses"]["gone"];
    };
  };
  /**
   * The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
   * [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
   * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
   * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
   * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
   * to the [`issues`](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#issues) webhook.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/get": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** issue_number parameter */
        issue_number: components["parameters"]["issue-number"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["issue"];
        };
      };
      301: components["responses"]["moved_permanently"];
      304: components["responses"]["not_modified"];
      404: components["responses"]["not_found"];
      410: components["responses"]["gone"];
    };
  };
  /** Issue owners and users with push access can edit an issue. */
  "issues/update": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** issue_number parameter */
        issue_number: components["parameters"]["issue-number"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["issue"];
        };
      };
      301: components["responses"]["moved_permanently"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      410: components["responses"]["gone"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The title of the issue. */
          title?: (string | number) | null;
          /** The contents of the issue. */
          body?: string | null;
          /** Login for the user that this issue should be assigned to. **This field is deprecated.** */
          assignee?: string | null;
          /** State of the issue. Either `open` or `closed`. */
          state?: "open" | "closed";
          milestone?: (string | number) | null;
          /** Labels to associate with this issue. Pass one or more Labels to _replace_ the set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from the Issue. _NOTE: Only users with push access can set labels for issues. Labels are silently dropped otherwise._ */
          labels?: (
            | string
            | {
                id?: number;
                name?: string;
                description?: string | null;
                color?: string | null;
              }
          )[];
          /** Logins for Users to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this Issue. Send an empty array (`[]`) to clear all assignees from the Issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._ */
          assignees?: string[];
        };
      };
    };
  };
  /** Adds up to 10 assignees to an issue. Users already assigned to an issue are not replaced. */
  "issues/add-assignees": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** issue_number parameter */
        issue_number: components["parameters"]["issue-number"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["issue-simple"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._ */
          assignees?: string[];
        };
      };
    };
  };
  /** List all notifications for the current user. */
  "activity/list-repo-notifications-for-authenticated-user": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** If `true`, show notifications marked as read. */
        all?: components["parameters"]["all"];
        /** If `true`, only shows notifications in which the user is directly participating or mentioned. */
        participating?: components["parameters"]["participating"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        before?: components["parameters"]["before"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["thread"][];
        };
      };
    };
  };
  /** Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. */
  "pulls/list": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Either `open`, `closed`, or `all` to filter by state. */
        state?: "open" | "closed" | "all";
        /** Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`. */
        head?: string;
        /** Filter pulls by base branch name. Example: `gh-pages`. */
        base?: string;
        /** What to sort results by. Can be either `created`, `updated`, `popularity` (comment count) or `long-running` (age, filtering by pulls updated in the last month). */
        sort?: "created" | "updated" | "popularity" | "long-running";
        /** The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`. */
        direction?: "asc" | "desc";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["pull-request-simple"][];
        };
      };
      304: components["responses"]["not_modified"];
      422: components["responses"]["validation_failed"];
    };
  };
  /** This endpoint triggers [notifications](https://docs.github.com/enterprise-server@3.1/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details. */
  "pulls/request-reviewers": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        pull_number: components["parameters"]["pull-number"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["pull-request-simple"];
        };
      };
      403: components["responses"]["forbidden"];
      /** Unprocessable Entity if user is not a collaborator */
      422: unknown;
    };
    requestBody: {
      content: {
        "application/json": {
          /** An array of user `login`s that will be requested. */
          reviewers?: string[];
          /** An array of team `slug`s that will be requested. */
          team_reviewers?: string[];
        };
      };
    };
  };
  /**
   * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-repository-tags).
   *
   * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
   */
  "repos/list-releases": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["release"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Users with push access to the repository can create a release.
   *
   * This endpoint triggers [notifications](https://docs.github.com/en/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/enterprise-server@3.1/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
   */
  "repos/create-release": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the tag. */
          tag_name: string;
          /** Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`). */
          target_commitish?: string;
          /** The name of the release. */
          name?: string;
          /** Text describing the contents of the tag. */
          body?: string;
          /** `true` to create a draft (unpublished) release, `false` to create a published one. */
          draft?: boolean;
          /** `true` to identify the release as a prerelease. `false` to identify the release as a full release. */
          prerelease?: boolean;
        };
      };
    };
  };
  /**
   * View the latest published full release for the repository.
   *
   * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
   */
  "repos/get-latest-release": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
    };
  };
  /** Get a published release with the specified tag. */
  "repos/get-release-by-tag": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** tag parameter */
        tag: string;
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#hypermedia). */
  "repos/get-release": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** release_id parameter */
        release_id: components["parameters"]["release-id"];
      };
    };
    responses: {
      /** **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#hypermedia). */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Users with push access to the repository can edit a release. */
  "repos/update-release": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** release_id parameter */
        release_id: components["parameters"]["release-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the tag. */
          tag_name?: string;
          /** Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`). */
          target_commitish?: string;
          /** The name of the release. */
          name?: string;
          /** Text describing the contents of the tag. */
          body?: string;
          /** `true` makes the release a draft, and `false` publishes the release. */
          draft?: boolean;
          /** `true` to identify the release as a prerelease, `false` to identify the release as a full release. */
          prerelease?: boolean;
        };
      };
    };
  };
  /** A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://help.github.com/articles/about-repository-transfers/). */
  "repos/transfer": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      202: {
        content: {
          "application/json": components["schemas"]["minimal-repository"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The username or organization name the repository will be transferred to. */
          new_owner: string;
          /** ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories. */
          team_ids?: number[];
        };
      };
    };
  };
  /**
   * Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. The authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
   *
   * **OAuth scope requirements**
   *
   * When using [OAuth](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
   *
   * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
   * *   `repo` scope to create a private repository
   */
  "repos/create-using-template": {
    parameters: {
      path: {
        template_owner: string;
        template_repo: string;
      };
    };
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["repository"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization. */
          owner?: string;
          /** The name of the new repository. */
          name: string;
          /** A short description of the new repository. */
          description?: string;
          /** Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`. */
          include_all_branches?: boolean;
          /** Either `true` to create a new private repository or `false` to create a new public one. */
          private?: boolean;
        };
      };
    };
  };
  /**
   * Lists all public repositories in the order that they were created.
   *
   * Note:
   * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
   * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
   */
  "repos/list-public": {
    parameters: {
      query: {
        /** A repository ID. Only return repositories with an ID greater than this ID. */
        since?: components["parameters"]["since-repo"];
        /** Specifies the types of repositories to return. Can be one of `all` or `public`. Default: `public`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. */
        visibility?: "all" | "public";
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {
          Link?: string;
        };
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      422: components["responses"]["validation_failed"];
    };
  };
  /**
   * Searches for query terms inside of a file. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
   *
   * When searching for code, you can get text match metadata for the file **content** and file **path** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
   *
   * For example, if you want to find the definition of the `addClass` function inside [jQuery](https://github.com/jquery/jquery) repository, your query would look something like this:
   *
   * `q=addClass+in:file+language:js+repo:jquery/jquery`
   *
   * This query searches for the keyword `addClass` within a file's contents. The query limits the search to files where the language is JavaScript in the `jquery/jquery` repository.
   *
   * #### Considerations for code search
   *
   * Due to the complexity of searching code, there are a few restrictions on how searches are performed:
   *
   * *   Only the _default branch_ is considered. In most cases, this will be the `master` branch.
   * *   Only files smaller than 384 KB are searchable.
   * *   You must always include at least one search term when searching source code. For example, searching for [`language:go`](https://github.com/search?utf8=%E2%9C%93&q=language%3Ago&type=Code) is not valid, while [`amazing
   * language:go`](https://github.com/search?utf8=%E2%9C%93&q=amazing+language%3Ago&type=Code) is.
   */
  "search/code": {
    parameters: {
      query: {
        /** The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.1/rest/reference/search#constructing-a-search-query). See "[Searching code](https://help.github.com/articles/searching-code/)" for a detailed list of qualifiers. */
        q: string;
        /** Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub Enterprise Server search infrastructure. Default: [best match](https://docs.github.com/enterprise-server@3.1/rest/reference/search#ranking-search-results) */
        sort?: "indexed";
        /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
        order?: components["parameters"]["order"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            incomplete_results: boolean;
            items: components["schemas"]["code-search-result-item"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /**
   * Find commits via various criteria on the default branch (usually `master`). This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
   *
   * When searching for commits, you can get text match metadata for the **message** field when you provide the `text-match` media type. For more details about how to receive highlighted search results, see [Text match
   * metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
   *
   * For example, if you want to find commits related to CSS in the [octocat/Spoon-Knife](https://github.com/octocat/Spoon-Knife) repository. Your query would look something like this:
   *
   * `q=repo:octocat/Spoon-Knife+css`
   */
  "search/commits": {
    parameters: {
      query: {
        /** The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.1/rest/reference/search#constructing-a-search-query). See "[Searching commits](https://help.github.com/articles/searching-commits/)" for a detailed list of qualifiers. */
        q: string;
        /** Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://docs.github.com/enterprise-server@3.1/rest/reference/search#ranking-search-results) */
        sort?: "author-date" | "committer-date";
        /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
        order?: components["parameters"]["order"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            incomplete_results: boolean;
            items: components["schemas"]["commit-search-result-item"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      415: components["responses"]["preview_header_missing"];
    };
  };
  /**
   * Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
   *
   * When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
   * search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
   *
   * For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
   *
   * `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
   *
   * This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
   *
   * **Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
   */
  "search/issues-and-pull-requests": {
    parameters: {
      query: {
        /** The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.1/rest/reference/search#constructing-a-search-query). See "[Searching issues and pull requests](https://help.github.com/articles/searching-issues-and-pull-requests/)" for a detailed list of qualifiers. */
        q: string;
        /** Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/enterprise-server@3.1/rest/reference/search#ranking-search-results) */
        sort?:
          | "comments"
          | "reactions"
          | "reactions-+1"
          | "reactions--1"
          | "reactions-smile"
          | "reactions-thinking_face"
          | "reactions-heart"
          | "reactions-tada"
          | "interactions"
          | "created"
          | "updated";
        /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
        order?: components["parameters"]["order"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            incomplete_results: boolean;
            items: components["schemas"]["issue-search-result-item"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /**
   * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
   *
   * When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
   *
   * For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
   *
   * `q=tetris+language:assembly&sort=stars&order=desc`
   *
   * This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
   *
   * When you include the `mercy` preview header, you can also search for multiple topics by adding more `topic:` instances. For example, your query might look like this:
   *
   * `q=topic:ruby+topic:rails`
   */
  "search/repos": {
    parameters: {
      query: {
        /** The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.1/rest/reference/search#constructing-a-search-query). See "[Searching for repositories](https://help.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers. */
        q: string;
        /** Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/enterprise-server@3.1/rest/reference/search#ranking-search-results) */
        sort?: "stars" | "forks" | "help-wanted-issues" | "updated";
        /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
        order?: components["parameters"]["order"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            incomplete_results: boolean;
            items: components["schemas"]["repo-search-result-item"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /** **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [List team repositories](https://docs.github.com/enterprise-server@3.1/rest/reference/teams#list-team-repositories) endpoint. */
  "teams/list-repos-legacy": {
    parameters: {
      path: {
        team_id: components["parameters"]["team-id"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * **Note**: Repositories inherited through a parent team will also be checked.
   *
   * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/enterprise-server@3.1/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
   *
   * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
   */
  "teams/check-permissions-for-repo-legacy": {
    parameters: {
      path: {
        team_id: components["parameters"]["team-id"];
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Alternative response with extra repository information */
      200: {
        content: {
          "application/json": components["schemas"]["team-repository"];
        };
      };
      /** Response if repository is managed by this team */
      204: never;
      /** Not Found if repository is not managed by this team */
      404: unknown;
    };
  };
  /**
   * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
   *
   * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
   *
   * You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
   *
   * The access the user has to each repository is included in the hash under the `permissions` key.
   */
  "apps/list-installation-repos-for-authenticated-user": {
    parameters: {
      path: {
        /** installation_id parameter */
        installation_id: components["parameters"]["installation-id"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** The access the user has to each repository is included in the hash under the `permissions` key. */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            repository_selection?: string;
            repositories: components["schemas"]["repository"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * List issues across owned and member repositories assigned to the authenticated user.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list-for-authenticated-user": {
    parameters: {
      query: {
        /**
         * Indicates which sorts of issues to return. Can be one of:
         * \* `assigned`: Issues assigned to you
         * \* `created`: Issues created by you
         * \* `mentioned`: Issues mentioning you
         * \* `subscribed`: Issues you're subscribed to updates for
         * \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
         */
        filter?:
          | "assigned"
          | "created"
          | "mentioned"
          | "subscribed"
          | "repos"
          | "all";
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue"][];
        };
      };
      304: components["responses"]["not_modified"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
   *
   * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
   */
  "repos/list-for-authenticated-user": {
    parameters: {
      query: {
        /** Can be one of `all`, `public`, or `private`. Note: For GitHub AE, can be one of `all`, `internal`, or `private`. */
        visibility?: "all" | "public" | "private";
        /**
         * Comma-separated list of values. Can include:
         * \* `owner`: Repositories that are owned by the authenticated user.
         * \* `collaborator`: Repositories that the user has been added to as a collaborator.
         * \* `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
         */
        affiliation?: string;
        /**
         * Can be one of `all`, `owner`, `public`, `private`, `member`. Note: For GitHub AE, can be one of `all`, `owner`, `internal`, `private`, `member`. Default: `all`
         *
         * Will cause a `422` error if used in the same request as **visibility** or **affiliation**. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
         */
        type?: "all" | "owner" | "public" | "private" | "member";
        /** Can be one of `created`, `updated`, `pushed`, `full_name`. */
        sort?: "created" | "updated" | "pushed" | "full_name";
        /** Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc` */
        direction?: "asc" | "desc";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        before?: components["parameters"]["before"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
    };
  };
  /**
   * Creates a new repository for the authenticated user.
   *
   * **OAuth scope requirements**
   *
   * When using [OAuth](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/), authorizations must include:
   *
   * *   `public_repo` scope or `repo` scope to create a public repository. Note: For GitHub AE, use `repo` scope to create an internal repository.
   * *   `repo` scope to create a private repository.
   */
  "repos/create-for-authenticated-user": {
    parameters: {};
    responses: {
      /** Response */
      201: {
        headers: {
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["repository"];
        };
      };
      304: components["responses"]["not_modified"];
      400: components["responses"]["bad_request"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the repository. */
          name: string;
          /** A short description of the repository. */
          description?: string;
          /** A URL with more information about the repository. */
          homepage?: string;
          /** Whether the repository is private. */
          private?: boolean;
          /** Whether issues are enabled. */
          has_issues?: boolean;
          /** Whether projects are enabled. */
          has_projects?: boolean;
          /** Whether the wiki is enabled. */
          has_wiki?: boolean;
          /** The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization. */
          team_id?: number;
          /** Whether the repository is initialized with a minimal README. */
          auto_init?: boolean;
          /** The desired language or platform to apply to the .gitignore. */
          gitignore_template?: string;
          /** The license keyword of the open source license for this repository. */
          license_template?: string;
          /** Whether to allow squash merges for pull requests. */
          allow_squash_merge?: boolean;
          /** Whether to allow merge commits for pull requests. */
          allow_merge_commit?: boolean;
          /** Whether to allow rebase merges for pull requests. */
          allow_rebase_merge?: boolean;
          /** Whether to delete head branches when pull requests are merged */
          delete_branch_on_merge?: boolean;
          /** Whether downloads are enabled. */
          has_downloads?: boolean;
          /** Whether this repository acts as a template that can be used to generate new repositories. */
          is_template?: boolean;
        };
      };
    };
  };
  /** When authenticating as a user, this endpoint will list all currently open repository invitations for that user. */
  "repos/list-invitations-for-authenticated-user": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["repository-invitation"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Lists repositories the authenticated user has starred.
   *
   * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
   */
  "activity/list-repos-starred-by-authenticated-user": {
    parameters: {
      query: {
        /** One of `created` (when the repository was starred) or `updated` (when it was last pushed to). */
        sort?: components["parameters"]["sort"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["repository"][];
          "application/vnd.github.v3.star+json": components["schemas"]["starred-repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /** Lists repositories the authenticated user is watching. */
  "activity/list-watched-repos-for-authenticated-user": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /** If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. */
  "activity/list-events-for-authenticated-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  /** This is the user's organization dashboard. You must be authenticated as the user to view this. */
  "activity/list-org-events-for-authenticated-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "activity/list-public-events-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  /** These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events. */
  "activity/list-received-events-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "activity/list-received-public-events-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  /** Lists public repositories for the specified user. Note: For GitHub AE, this endpoint will list internal repositories for the specified user. */
  "repos/list-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Can be one of `all`, `owner`, `member`. */
        type?: "all" | "owner" | "member";
        /** Can be one of `created`, `updated`, `pushed`, `full_name`. */
        sort?: "created" | "updated" | "pushed" | "full_name";
        /** Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc` */
        direction?: "asc" | "desc";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
    };
  };
  /** Lists repositories a user is watching. */
  "activity/list-repos-watched-by-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
    };
  };
}

export interface external {}
