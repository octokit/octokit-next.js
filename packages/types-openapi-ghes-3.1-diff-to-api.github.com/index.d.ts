/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/admin/hooks": {
    get: operations["enterprise-admin/list-global-webhooks"];
    post: operations["enterprise-admin/create-global-webhook"];
  };
  "/admin/hooks/{hook_id}": {
    get: operations["enterprise-admin/get-global-webhook"];
    delete: operations["enterprise-admin/delete-global-webhook"];
    /** Parameters that are not provided will be overwritten with the default value or removed if no default exists. */
    patch: operations["enterprise-admin/update-global-webhook"];
  };
  "/admin/hooks/{hook_id}/pings": {
    /** This will trigger a [ping event](https://docs.github.com/enterprise-server@3.1/webhooks/#ping-event) to be sent to the webhook. */
    post: operations["enterprise-admin/ping-global-webhook"];
  };
  "/admin/keys": {
    get: operations["enterprise-admin/list-public-keys"];
  };
  "/admin/keys/{key_ids}": {
    delete: operations["enterprise-admin/delete-public-key"];
  };
  "/admin/ldap/teams/{team_id}/mapping": {
    /**
     * Updates the [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team. [LDAP synchronization](https://help.github.com/enterprise/admin/guides/user-management/using-ldap/#enabling-ldap-sync) must be enabled to map LDAP entries to a team. Use the [Create a team](https://docs.github.com/enterprise-server@3.1/rest/reference/teams/#create-a-team) endpoint to create a team with LDAP mapping.
     *
     * If you pass the `hellcat-preview` media type, you can also update the LDAP mapping of a child team.
     */
    patch: operations["enterprise-admin/update-ldap-mapping-for-team"];
  };
  "/admin/ldap/teams/{team_id}/sync": {
    /** Note that this API call does not automatically initiate an LDAP sync. Rather, if a `201` is returned, the sync job is queued successfully, and is performed when the instance is ready. */
    post: operations["enterprise-admin/sync-ldap-mapping-for-team"];
  };
  "/admin/ldap/users/{username}/mapping": {
    patch: operations["enterprise-admin/update-ldap-mapping-for-user"];
  };
  "/admin/ldap/users/{username}/sync": {
    /** Note that this API call does not automatically initiate an LDAP sync. Rather, if a `201` is returned, the sync job is queued successfully, and is performed when the instance is ready. */
    post: operations["enterprise-admin/sync-ldap-mapping-for-user"];
  };
  "/admin/organizations": {
    post: operations["enterprise-admin/create-org"];
  };
  "/admin/organizations/{org}": {
    patch: operations["enterprise-admin/update-org-name"];
  };
  "/admin/pre-receive-environments": {
    get: operations["enterprise-admin/list-pre-receive-environments"];
    post: operations["enterprise-admin/create-pre-receive-environment"];
  };
  "/admin/pre-receive-environments/{pre_receive_environment_id}": {
    get: operations["enterprise-admin/get-pre-receive-environment"];
    /**
     * If you attempt to delete an environment that cannot be deleted, you will receive a `422 Unprocessable Entity` response.
     *
     * The possible error messages are:
     *
     * *   _Cannot modify or delete the default environment_
     * *   _Cannot delete environment that has hooks_
     * *   _Cannot delete environment when download is in progress_
     */
    delete: operations["enterprise-admin/delete-pre-receive-environment"];
    /** You cannot modify the default environment. If you attempt to modify the default environment, you will receive a `422 Unprocessable Entity` response. */
    patch: operations["enterprise-admin/update-pre-receive-environment"];
  };
  "/admin/pre-receive-environments/{pre_receive_environment_id}/downloads": {
    /**
     * Triggers a new download of the environment tarball from the environment's `image_url`. When the download is finished, the newly downloaded tarball will overwrite the existing environment.
     *
     * If a download cannot be triggered, you will receive a `422 Unprocessable Entity` response.
     *
     * The possible error messages are:
     *
     * * _Cannot modify or delete the default environment_
     * * _Can not start a new download when a download is in progress_
     */
    post: operations["enterprise-admin/start-pre-receive-environment-download"];
  };
  "/admin/pre-receive-environments/{pre_receive_environment_id}/downloads/latest": {
    /** In addition to seeing the download status at the "[Get a pre-receive environment](#get-a-pre-receive-environment)" endpoint, there is also this separate endpoint for just the download status. */
    get: operations["enterprise-admin/get-download-status-for-pre-receive-environment"];
  };
  "/admin/pre-receive-hooks": {
    get: operations["enterprise-admin/list-pre-receive-hooks"];
    post: operations["enterprise-admin/create-pre-receive-hook"];
  };
  "/admin/pre-receive-hooks/{pre_receive_hook_id}": {
    get: operations["enterprise-admin/get-pre-receive-hook"];
    delete: operations["enterprise-admin/delete-pre-receive-hook"];
    patch: operations["enterprise-admin/update-pre-receive-hook"];
  };
  "/admin/tokens": {
    /** Lists personal access tokens for all users, including admin users. */
    get: operations["enterprise-admin/list-personal-access-tokens"];
  };
  "/admin/tokens/{token_id}": {
    /** Deletes a personal access token. Returns a `403 - Forbidden` status when a personal access token is in use. For example, if you access this endpoint with the same personal access token that you are trying to delete, you will receive this error. */
    delete: operations["enterprise-admin/delete-personal-access-token"];
  };
  "/admin/users": {
    /**
     * If an external authentication mechanism is used, the login name should match the login name in the external system. If you are using LDAP authentication, you should also [update the LDAP mapping](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#update-ldap-mapping-for-a-user) for the user.
     *
     * The login name will be normalized to only contain alphanumeric characters or single hyphens. For example, if you send `"octo_cat"` as the login, a user named `"octo-cat"` will be created.
     *
     * If the login name or email address is already associated with an account, the server will return a `422` response.
     */
    post: operations["enterprise-admin/create-user"];
  };
  "/admin/users/{username}": {
    /**
     * Deleting a user will delete all their repositories, gists, applications, and personal settings. [Suspending a user](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#suspend-a-user) is often a better option.
     *
     * You can delete any user account except your own.
     */
    delete: operations["enterprise-admin/delete-user"];
    patch: operations["enterprise-admin/update-username-for-user"];
  };
  "/admin/users/{username}/authorizations": {
    post: operations["enterprise-admin/create-impersonation-o-auth-token"];
    delete: operations["enterprise-admin/delete-impersonation-o-auth-token"];
  };
  "/applications/{client_id}/grants/{access_token}": {
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid token as `:access_token` and the grant for the token's owner will be deleted.
     *
     * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the Applications settings page under "Authorized OAuth Apps" on GitHub Enterprise Server](https://github.com/settings/applications#authorized).
     */
    delete: operations["apps/revoke-grant-for-application"];
  };
  "/applications/{client_id}/tokens/{access_token}": {
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     */
    get: operations["apps/check-authorization"];
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
     */
    post: operations["apps/reset-authorization"];
    /**
     * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
     *
     * OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
     */
    delete: operations["apps/revoke-authorization-for-application"];
  };
  "/enterprise/announcement": {
    /** Gets the current message and expiration date of the global announcement banner in your enterprise. */
    get: operations["enterprise-admin/get-announcement"];
    /** Removes the global announcement banner in your enterprise. */
    delete: operations["enterprise-admin/remove-announcement"];
    /** Sets the message and expiration time for the global announcement banner in your enterprise. */
    patch: operations["enterprise-admin/set-announcement"];
  };
  "/enterprise/settings/license": {
    get: operations["enterprise-admin/get-license-information"];
  };
  "/enterprise/stats/all": {
    get: operations["enterprise-admin/get-all-stats"];
  };
  "/enterprise/stats/comments": {
    get: operations["enterprise-admin/get-comment-stats"];
  };
  "/enterprise/stats/gists": {
    get: operations["enterprise-admin/get-all-stats"];
  };
  "/enterprise/stats/hooks": {
    get: operations["enterprise-admin/get-hooks-stats"];
  };
  "/enterprise/stats/issues": {
    get: operations["enterprise-admin/get-issue-stats"];
  };
  "/enterprise/stats/milestones": {
    get: operations["enterprise-admin/get-milestone-stats"];
  };
  "/enterprise/stats/orgs": {
    get: operations["enterprise-admin/get-org-stats"];
  };
  "/enterprise/stats/pages": {
    get: operations["enterprise-admin/get-pages-stats"];
  };
  "/enterprise/stats/pulls": {
    get: operations["enterprise-admin/get-pull-request-stats"];
  };
  "/enterprise/stats/repos": {
    get: operations["enterprise-admin/get-repo-stats"];
  };
  "/enterprise/stats/users": {
    get: operations["enterprise-admin/get-user-stats"];
  };
  "/enterprises/{enterprise}/actions/permissions/selected-actions": {
    /**
     * Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
     *
     * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
     */
    get: operations["enterprise-admin/get-allowed-actions-enterprise"];
  };
  "/events": {
    /** We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago. */
    get: operations["activity/list-public-events"];
  };
  "/installation/repositories": {
    /**
     * List repositories that an app installation can access.
     *
     * You must use an [installation access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
     */
    get: operations["apps/list-repos-accessible-to-installation"];
  };
  "/issues": {
    /**
     * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
     * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
     * necessarily assigned to you.
     *
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list"];
  };
  "/meta": {
    get: operations["meta/get"];
  };
  "/networks/{owner}/{repo}/events": {
    get: operations["activity/list-public-events-for-repo-network"];
  };
  "/orgs/{org}/actions/permissions/repositories": {
    /**
     * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     */
    get: operations["actions/list-selected-repositories-enabled-github-actions-organization"];
  };
  "/orgs/{org}/actions/permissions/selected-actions": {
    /**
     * Gets the selected actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""
     *
     * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
     */
    get: operations["actions/get-allowed-actions-organization"];
  };
  "/orgs/{org}/events": {
    get: operations["activity/list-public-org-events"];
  };
  "/orgs/{org}/hooks": {
    get: operations["orgs/list-webhooks"];
  };
  "/orgs/{org}/hooks/{hook_id}": {
    /** Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)." */
    get: operations["orgs/get-webhook"];
  };
  "/orgs/{org}/issues": {
    /**
     * List issues in an organization assigned to the authenticated user.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list-for-org"];
  };
  "/orgs/{org}/pre-receive-hooks": {
    /** List all pre-receive hooks that are enabled or testing for this organization as well as any disabled hooks that can be configured at the organization level. Globally disabled pre-receive hooks that do not allow downstream configuration are not listed. */
    get: operations["enterprise-admin/list-pre-receive-hooks-for-org"];
  };
  "/orgs/{org}/pre-receive-hooks/{pre_receive_hook_id}": {
    get: operations["enterprise-admin/get-pre-receive-hook-for-org"];
    /** Removes any overrides for this hook at the org level for this org. */
    delete: operations["enterprise-admin/remove-pre-receive-hook-enforcement-for-org"];
    /** For pre-receive hooks which are allowed to be configured at the org level, you can set `enforcement` and `allow_downstream_configuration` */
    patch: operations["enterprise-admin/update-pre-receive-hook-enforcement-for-org"];
  };
  "/orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}": {
    /**
     * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
     *
     * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
     *
     * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
     *
     * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
     */
    get: operations["teams/check-permissions-for-repo-in-org"];
  };
  "/repos/{owner}/{repo}": {
    /**
     * When you pass the `scarlet-witch-preview` media type, requests to get a repository will also return the repository's code of conduct if it can be detected from the repository's code of conduct file.
     *
     * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
     */
    get: operations["repos/get"];
  };
  "/repos/{owner}/{repo}/actions/permissions/selected-actions": {
    /**
     * Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
     *
     * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
     */
    get: operations["actions/get-allowed-actions-repository"];
  };
  "/repos/{owner}/{repo}/code-scanning/alerts/{alert_number}": {
    /**
     * Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
     *
     * **Deprecation notice**:
     * The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
     */
    get: operations["code-scanning/get-alert"];
  };
  "/repos/{owner}/{repo}/commits/{commit_sha}/pulls": {
    /** Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. Additional preview headers may be required to see certain details for associated pull requests, such as whether a pull request is in a draft state. For more information about previews that might affect this endpoint, see the [List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests) endpoint. */
    get: operations["repos/list-pull-requests-associated-with-commit"];
  };
  "/repos/{owner}/{repo}/compare/{basehead}": {
    /**
     * The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.
     *
     * The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
     *
     * The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
     *
     * **Working with large comparisons**
     *
     * The response will include a comparison of up to 250 commits. If you are working with a larger commit range, you can use the [List commits](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-commits) to enumerate all commits in the range.
     *
     * For comparisons with extremely large diffs, you may receive an error response indicating that the diff took too long
     * to generate. You can typically resolve this error by using a smaller commit range.
     *
     * **Signature verification object**
     *
     * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
     *
     * | Name | Type | Description |
     * | ---- | ---- | ----------- |
     * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
     * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
     * | `signature` | `string` | The signature that was extracted from the commit. |
     * | `payload` | `string` | The value that was signed. |
     *
     * These are the possible values for `reason` in the `verification` object:
     *
     * | Value | Description |
     * | ----- | ----------- |
     * | `expired_key` | The key that made the signature is expired. |
     * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
     * | `gpgverify_error` | There was an error communicating with the signature verification service. |
     * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
     * | `unsigned` | The object does not include a signature. |
     * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
     * | `no_user` | No user was associated with the `committer` email address in the commit. |
     * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
     * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
     * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
     * | `malformed_signature` | There was an error parsing the signature. |
     * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
     * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
     */
    get: operations["repos/compare-commits-with-basehead"];
  };
  "/repos/{owner}/{repo}/events": {
    get: operations["activity/list-repo-events"];
  };
  "/repos/{owner}/{repo}/hooks": {
    get: operations["repos/list-webhooks"];
  };
  "/repos/{owner}/{repo}/hooks/{hook_id}": {
    /** Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)." */
    get: operations["repos/get-webhook"];
  };
  "/repos/{owner}/{repo}/issues": {
    /**
     * List issues in a repository.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list-for-repo"];
  };
  "/repos/{owner}/{repo}/issues/events": {
    get: operations["issues/list-events-for-repo"];
  };
  "/repos/{owner}/{repo}/issues/events/{event_id}": {
    get: operations["issues/get-event"];
  };
  "/repos/{owner}/{repo}/issues/{issue_number}": {
    /**
     * The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
     * [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
     * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
     * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
     * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
     * to the [`issues`](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#issues) webhook.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/get"];
  };
  "/repos/{owner}/{repo}/pre-receive-hooks": {
    /** List all pre-receive hooks that are enabled or testing for this repository as well as any disabled hooks that are allowed to be enabled at the repository level. Pre-receive hooks that are disabled at a higher level and are not configurable will not be listed. */
    get: operations["enterprise-admin/list-pre-receive-hooks-for-repo"];
  };
  "/repos/{owner}/{repo}/pre-receive-hooks/{pre_receive_hook_id}": {
    get: operations["enterprise-admin/get-pre-receive-hook-for-repo"];
    /**
     * Deletes any overridden enforcement on this repository for the specified hook.
     *
     * Responds with effective values inherited from owner and/or global level.
     */
    delete: operations["enterprise-admin/remove-pre-receive-hook-enforcement-for-repo"];
    /** For pre-receive hooks which are allowed to be configured at the repo level, you can set `enforcement` */
    patch: operations["enterprise-admin/update-pre-receive-hook-enforcement-for-repo"];
  };
  "/repos/{owner}/{repo}/pulls": {
    /** Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. */
    get: operations["pulls/list"];
  };
  "/repos/{owner}/{repo}/releases": {
    /**
     * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-repository-tags).
     *
     * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
     */
    get: operations["repos/list-releases"];
  };
  "/repos/{owner}/{repo}/releases/latest": {
    /**
     * View the latest published full release for the repository.
     *
     * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
     */
    get: operations["repos/get-latest-release"];
  };
  "/repos/{owner}/{repo}/releases/tags/{tag}": {
    /** Get a published release with the specified tag. */
    get: operations["repos/get-release-by-tag"];
  };
  "/repos/{owner}/{repo}/releases/{release_id}": {
    /** **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#hypermedia). */
    get: operations["repos/get-release"];
  };
  "/repositories": {
    /**
     * Lists all public repositories in the order that they were created.
     *
     * Note:
     * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
     * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
     */
    get: operations["repos/list-public"];
  };
  "/search/issues": {
    /**
     * Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
     * search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
     *
     * `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
     *
     * This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
     *
     * **Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
     */
    get: operations["search/issues-and-pull-requests"];
  };
  "/search/repositories": {
    /**
     * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
     *
     * When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
     *
     * For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
     *
     * `q=tetris+language:assembly&sort=stars&order=desc`
     *
     * This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
     *
     * When you include the `mercy` preview header, you can also search for multiple topics by adding more `topic:` instances. For example, your query might look like this:
     *
     * `q=topic:ruby+topic:rails`
     */
    get: operations["search/repos"];
  };
  "/setup/api/configcheck": {
    /**
     * This endpoint allows you to check the status of the most recent configuration process:
     *
     * Note that you may need to wait several seconds after you start a process before you can check its status.
     *
     * The different statuses are:
     *
     * | Status        | Description                       |
     * | ------------- | --------------------------------- |
     * | `PENDING`     | The job has not started yet       |
     * | `CONFIGURING` | The job is running                |
     * | `DONE`        | The job has finished correctly    |
     * | `FAILED`      | The job has finished unexpectedly |
     */
    get: operations["enterprise-admin/get-configuration-status"];
  };
  "/setup/api/configure": {
    /** This endpoint allows you to start a configuration process at any time for your updated settings to take effect: */
    post: operations["enterprise-admin/start-configuration-process"];
  };
  "/setup/api/maintenance": {
    /** Check your installation's maintenance status: */
    get: operations["enterprise-admin/get-maintenance-status"];
    /** **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode). */
    post: operations["enterprise-admin/enable-or-disable-maintenance-mode"];
  };
  "/setup/api/settings": {
    get: operations["enterprise-admin/get-settings"];
    /**
     * For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#get-settings).
     *
     * **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
     */
    put: operations["enterprise-admin/set-settings"];
  };
  "/setup/api/settings/authorized-keys": {
    get: operations["enterprise-admin/get-all-authorized-ssh-keys"];
    /** **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode). */
    post: operations["enterprise-admin/add-authorized-ssh-key"];
    /** **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode). */
    delete: operations["enterprise-admin/remove-authorized-ssh-key"];
  };
  "/setup/api/start": {
    /**
     * When you boot a GitHub instance for the first time, you can use the following endpoint to upload a license.
     *
     * Note that you need to `POST` to [`/setup/api/configure`](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#start-a-configuration-process) to start the actual configuration process.
     *
     * When using this endpoint, your GitHub instance must have a password set. This can be accomplished two ways:
     *
     * 1.  If you're working directly with the API before accessing the web interface, you must pass in the password parameter to set your password.
     * 2.  If you set up your instance via the web interface before accessing the API, your calls to this endpoint do not need the password parameter.
     *
     * **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
     */
    post: operations["enterprise-admin/create-enterprise-server-license"];
  };
  "/setup/api/upgrade": {
    /**
     * This API upgrades your license and also triggers the configuration process.
     *
     * **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
     */
    post: operations["enterprise-admin/upgrade-license"];
  };
  "/teams/{team_id}/repos/{owner}/{repo}": {
    /**
     * **Note**: Repositories inherited through a parent team will also be checked.
     *
     * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/enterprise-server@3.1/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
     *
     * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
     */
    get: operations["teams/check-permissions-for-repo-legacy"];
  };
  "/user/installations/{installation_id}/repositories": {
    /**
     * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     *
     * You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
     *
     * The access the user has to each repository is included in the hash under the `permissions` key.
     */
    get: operations["apps/list-installation-repos-for-authenticated-user"];
  };
  "/user/issues": {
    /**
     * List issues across owned and member repositories assigned to the authenticated user.
     *
     * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
     * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
     * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
     * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
     */
    get: operations["issues/list-for-authenticated-user"];
  };
  "/user/repos": {
    /**
     * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
     *
     * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
     */
    get: operations["repos/list-for-authenticated-user"];
  };
  "/user/starred": {
    /**
     * Lists repositories the authenticated user has starred.
     *
     * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
     */
    get: operations["activity/list-repos-starred-by-authenticated-user"];
  };
  "/users/{username}/events": {
    /** If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. */
    get: operations["activity/list-events-for-authenticated-user"];
  };
  "/users/{username}/events/orgs/{org}": {
    /** This is the user's organization dashboard. You must be authenticated as the user to view this. */
    get: operations["activity/list-org-events-for-authenticated-user"];
  };
  "/users/{username}/events/public": {
    get: operations["activity/list-public-events-for-user"];
  };
  "/users/{username}/received_events": {
    /** These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events. */
    get: operations["activity/list-received-events-for-user"];
  };
  "/users/{username}/received_events/public": {
    get: operations["activity/list-received-public-events-for-user"];
  };
  "/users/{username}/site_admin": {
    /** Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-verbs)." */
    put: operations["enterprise-admin/promote-user-to-be-site-administrator"];
    /** You can demote any user account except your own. */
    delete: operations["enterprise-admin/demote-site-administrator"];
  };
  "/users/{username}/suspended": {
    /**
     * If your GitHub instance uses [LDAP Sync with Active Directory LDAP servers](https://help.github.com/enterprise/admin/guides/user-management/using-ldap), Active Directory LDAP-authenticated users cannot be suspended through this API. If you attempt to suspend an Active Directory LDAP-authenticated user through this API, it will return a `403` response.
     *
     * You can suspend any user account except your own.
     *
     * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-verbs)."
     */
    put: operations["enterprise-admin/suspend-user"];
    /** If your GitHub instance uses [LDAP Sync with Active Directory LDAP servers](https://help.github.com/enterprise/admin/guides/user-management/using-ldap), this API is disabled and will return a `403` response. Active Directory LDAP-authenticated users cannot be unsuspended using the API. */
    delete: operations["enterprise-admin/unsuspend-user"];
  };
}

export interface components {
  schemas: {
    "global-hook": {
      type?: string;
      id?: number;
      name?: string;
      active?: boolean;
      events?: string[];
      config?: {
        url?: string;
        content_type?: string;
        insecure_ssl?: string;
        secret?: string;
      };
      updated_at?: string;
      created_at?: string;
      url?: string;
      ping_url?: string;
    };
    "global-hook-2": {
      type?: string;
      id?: number;
      name?: string;
      active?: boolean;
      events?: string[];
      config?: {
        url?: string;
        content_type?: string;
        insecure_ssl?: string;
      };
      updated_at?: string;
      created_at?: string;
      url?: string;
      ping_url?: string;
    };
    "public-key-full": {
      id: number;
      key: string;
      user_id: number | null;
      repository_id: number | null;
      url: string;
      title: string;
      read_only: boolean;
      verified: boolean;
      created_at: string;
      last_used: string | null;
    };
    "ldap-mapping-team": {
      ldap_dn?: string;
      id?: number;
      node_id?: string;
      url?: string;
      html_url?: string;
      name?: string;
      slug?: string;
      description?: string | null;
      privacy?: string;
      permission?: string;
      members_url?: string;
      repositories_url?: string;
      parent?: { [key: string]: unknown } | null;
    };
    /** Ldap Private User */
    "ldap-mapping-user": {
      ldap_dn?: string;
      login: string;
      id: number;
      node_id: string;
      avatar_url: string;
      gravatar_id: string | null;
      url: string;
      html_url: string;
      followers_url: string;
      following_url: string;
      gists_url: string;
      starred_url: string;
      subscriptions_url: string;
      organizations_url: string;
      repos_url: string;
      events_url: string;
      received_events_url: string;
      type: string;
      site_admin: boolean;
      name: string | null;
      company: string | null;
      blog: string | null;
      location: string | null;
      email: string | null;
      hireable: boolean | null;
      bio: string | null;
      twitter_username?: string | null;
      public_repos: number;
      public_gists: number;
      followers: number;
      following: number;
      created_at: string;
      updated_at: string;
      private_gists: number;
      total_private_repos: number;
      owned_private_repos: number;
      disk_usage: number;
      collaborators: number;
      two_factor_authentication: boolean;
      plan?: {
        collaborators: number;
        name: string;
        space: number;
        private_repos: number;
      };
      suspended_at?: string | null;
      business_plus?: boolean;
    };
    /** Organization Simple */
    "organization-simple": {
      login: string;
      id: number;
      node_id: string;
      url: string;
      repos_url: string;
      events_url: string;
      hooks_url: string;
      issues_url: string;
      members_url: string;
      public_members_url: string;
      avatar_url: string;
      description: string | null;
    };
    "pre-receive-environment": {
      id?: number;
      name?: string;
      image_url?: string;
      url?: string;
      html_url?: string;
      default_environment?: boolean;
      created_at?: string;
      hooks_count?: number;
      download?: {
        url?: string;
        state?: string;
        downloaded_at?: string | null;
        message?: string | null;
      };
    };
    "pre-receive-environment-download-status": {
      url?: string;
      state?: string;
      downloaded_at?: string | null;
      message?: string | null;
    };
    "pre-receive-hook": {
      id?: number;
      name?: string;
      enforcement?: string;
      script?: string;
      script_repository?: {
        id?: number;
        full_name?: string;
        url?: string;
        html_url?: string;
      };
      environment?: {
        id?: number;
        name?: string;
        image_url?: string;
        url?: string;
        html_url?: string;
        default_environment?: boolean;
        created_at?: string;
        hooks_count?: number;
        download?: {
          url?: string;
          state?: string;
          downloaded_at?: string | null;
          message?: string | null;
        };
      };
      allow_downstream_configuration?: boolean;
    };
    /** The authorization for an OAuth app, GitHub App, or a Personal Access Token. */
    authorization: {
      id: number;
      url: string;
      /** A list of scopes that this authorization is in. */
      scopes: string[] | null;
      token: string;
      token_last_eight: string | null;
      hashed_token: string | null;
      app: {
        client_id: string;
        name: string;
        url: string;
      };
      note: string | null;
      note_url: string | null;
      updated_at: string;
      created_at: string;
      fingerprint: string | null;
      user?: components["schemas"]["simple-user"] | null;
      installation?: components["schemas"]["scoped-installation"] | null;
    };
    /** Simple User */
    "simple-user": {
      name?: string | null;
      email?: string | null;
      login: string;
      id: number;
      node_id: string;
      avatar_url: string;
      gravatar_id: string | null;
      url: string;
      html_url: string;
      followers_url: string;
      following_url: string;
      gists_url: string;
      starred_url: string;
      subscriptions_url: string;
      organizations_url: string;
      repos_url: string;
      events_url: string;
      received_events_url: string;
      type: string;
      site_admin: boolean;
      starred_at?: string;
    } | null;
    /** Enterprise global announcement */
    announcement: {
      announcement: components["schemas"]["announcement-message"];
      expires_at?: components["schemas"]["announcement-expiration"];
    };
    "license-info": {
      seats?: string | number;
      seats_used?: number;
      seats_available?: string | number;
      kind?: string;
      days_until_expiration?: number;
      expire_at?: string;
    };
    "enterprise-overview": {
      repos?: components["schemas"]["enterprise-repository-overview"];
      hooks?: components["schemas"]["enterprise-hook-overview"];
      pages?: components["schemas"]["enterprise-page-overview"];
      orgs?: components["schemas"]["enterprise-organization-overview"];
      users?: components["schemas"]["enterprise-user-overview"];
      pulls?: components["schemas"]["enterprise-pull-request-overview"];
      issues?: components["schemas"]["enterprise-issue-overview"];
      milestones?: components["schemas"]["enterprise-milestone-overview"];
      gists?: components["schemas"]["enterprise-gist-overview"];
      comments?: components["schemas"]["enterprise-comment-overview"];
    };
    "enterprise-comment-overview": {
      total_commit_comments: number;
      total_gist_comments: number;
      total_issue_comments: number;
      total_pull_request_comments: number;
    };
    "enterprise-gist-overview": {
      total_gists: number;
      private_gists: number;
      public_gists: number;
    };
    "enterprise-hook-overview": {
      total_hooks: number;
      active_hooks: number;
      inactive_hooks: number;
    };
    "enterprise-issue-overview": {
      total_issues: number;
      open_issues: number;
      closed_issues: number;
    };
    "enterprise-milestone-overview": {
      total_milestones: number;
      open_milestones: number;
      closed_milestones: number;
    };
    "enterprise-organization-overview": {
      total_orgs: number;
      disabled_orgs: number;
      total_teams: number;
      total_team_members: number;
    };
    "enterprise-page-overview": {
      total_pages: number;
    };
    "enterprise-pull-request-overview": {
      total_pulls: number;
      merged_pulls: number;
      mergeable_pulls: number;
      unmergeable_pulls: number;
    };
    "enterprise-repository-overview": {
      total_repos: number;
      root_repos: number;
      fork_repos: number;
      org_repos: number;
      total_pushes: number;
      total_wikis: number;
    };
    "enterprise-user-overview": {
      total_users: number;
      admin_users: number;
      suspended_users: number;
    };
    "selected-actions": {
      /** Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization. */
      github_owned_allowed: boolean;
      /** Specifies a list of string-matching patterns to allow specific action(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`." */
      patterns_allowed: string[];
    };
    /** Event */
    event: {
      id: string;
      type: string | null;
      actor: components["schemas"]["actor"];
      repo: {
        id: number;
        name: string;
        url: string;
      };
      org?: components["schemas"]["actor"];
      payload: {
        action?: string;
        issue?: components["schemas"]["issue-simple"];
        comment?: components["schemas"]["issue-comment"];
        pages?: {
          page_name?: string;
          title?: string;
          summary?: string | null;
          action?: string;
          sha?: string;
          html_url?: string;
        }[];
      };
      public: boolean;
      created_at: string | null;
    };
    /** A git repository */
    repository: {
      /** Unique identifier of the repository */
      id: number;
      node_id: string;
      /** The name of the repository. */
      name: string;
      full_name: string;
      license: components["schemas"]["license-simple"] | null;
      organization?: components["schemas"]["simple-user"] | null;
      forks: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
      };
      owner: components["schemas"]["simple-user"];
      /** Whether the repository is private or public. */
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      /** The default branch of the repository. */
      default_branch: string;
      open_issues_count: number;
      /** Whether this repository acts as a template that can be used to generate new repositories. */
      is_template?: boolean;
      topics?: string[];
      /** Whether issues are enabled. */
      has_issues: boolean;
      /** Whether projects are enabled. */
      has_projects: boolean;
      /** Whether the wiki is enabled. */
      has_wiki: boolean;
      has_pages: boolean;
      /** Whether downloads are enabled. */
      has_downloads: boolean;
      /** Whether the repository is archived. */
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string | null;
      created_at: string | null;
      updated_at: string | null;
      /** Whether to allow rebase merges for pull requests. */
      allow_rebase_merge?: boolean;
      template_repository?: {
        id?: number;
        node_id?: string;
        name?: string;
        full_name?: string;
        owner?: {
          login?: string;
          id?: number;
          node_id?: string;
          avatar_url?: string;
          gravatar_id?: string;
          url?: string;
          html_url?: string;
          followers_url?: string;
          following_url?: string;
          gists_url?: string;
          starred_url?: string;
          subscriptions_url?: string;
          organizations_url?: string;
          repos_url?: string;
          events_url?: string;
          received_events_url?: string;
          type?: string;
          site_admin?: boolean;
        };
        private?: boolean;
        html_url?: string;
        description?: string;
        fork?: boolean;
        url?: string;
        archive_url?: string;
        assignees_url?: string;
        blobs_url?: string;
        branches_url?: string;
        collaborators_url?: string;
        comments_url?: string;
        commits_url?: string;
        compare_url?: string;
        contents_url?: string;
        contributors_url?: string;
        deployments_url?: string;
        downloads_url?: string;
        events_url?: string;
        forks_url?: string;
        git_commits_url?: string;
        git_refs_url?: string;
        git_tags_url?: string;
        git_url?: string;
        issue_comment_url?: string;
        issue_events_url?: string;
        issues_url?: string;
        keys_url?: string;
        labels_url?: string;
        languages_url?: string;
        merges_url?: string;
        milestones_url?: string;
        notifications_url?: string;
        pulls_url?: string;
        releases_url?: string;
        ssh_url?: string;
        stargazers_url?: string;
        statuses_url?: string;
        subscribers_url?: string;
        subscription_url?: string;
        tags_url?: string;
        teams_url?: string;
        trees_url?: string;
        clone_url?: string;
        mirror_url?: string;
        hooks_url?: string;
        svn_url?: string;
        homepage?: string;
        language?: string;
        forks_count?: number;
        stargazers_count?: number;
        watchers_count?: number;
        size?: number;
        default_branch?: string;
        open_issues_count?: number;
        is_template?: boolean;
        topics?: string[];
        has_issues?: boolean;
        has_projects?: boolean;
        has_wiki?: boolean;
        has_pages?: boolean;
        has_downloads?: boolean;
        archived?: boolean;
        disabled?: boolean;
        visibility?: string;
        pushed_at?: string;
        created_at?: string;
        updated_at?: string;
        permissions?: {
          admin?: boolean;
          maintain?: boolean;
          push?: boolean;
          triage?: boolean;
          pull?: boolean;
        };
        allow_rebase_merge?: boolean;
        temp_clone_token?: string;
        allow_squash_merge?: boolean;
        delete_branch_on_merge?: boolean;
        allow_merge_commit?: boolean;
        subscribers_count?: number;
        network_count?: number;
      } | null;
      temp_clone_token?: string;
      /** Whether to allow squash merges for pull requests. */
      allow_squash_merge?: boolean;
      /** Whether to delete head branches when pull requests are merged */
      delete_branch_on_merge?: boolean;
      /** Whether to allow merge commits for pull requests. */
      allow_merge_commit?: boolean;
      subscribers_count?: number;
      network_count?: number;
      open_issues: number;
      watchers: number;
      master_branch?: string;
      starred_at?: string;
    };
    /** Issues are a great way to keep track of tasks, enhancements, and bugs for your projects. */
    issue: {
      id: number;
      node_id: string;
      /** URL for the issue */
      url: string;
      repository_url: string;
      labels_url: string;
      comments_url: string;
      events_url: string;
      html_url: string;
      /** Number uniquely identifying the issue within its repository */
      number: number;
      /** State of the issue; either 'open' or 'closed' */
      state: string;
      /** Title of the issue */
      title: string;
      /** Contents of the issue */
      body?: string | null;
      user: components["schemas"]["simple-user"] | null;
      /** Labels to associate with this issue; pass one or more label names to replace the set of labels on this issue; send an empty array to clear all labels from the issue; note that the labels are silently dropped for users without push access to the repository */
      labels: (
        | string
        | {
            id?: number;
            node_id?: string;
            url?: string;
            name?: string;
            description?: string | null;
            color?: string | null;
            default?: boolean;
          }
      )[];
      assignee: components["schemas"]["simple-user"] | null;
      assignees?: components["schemas"]["simple-user"][] | null;
      milestone: components["schemas"]["milestone"] | null;
      locked: boolean;
      active_lock_reason?: string | null;
      comments: number;
      pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
      };
      closed_at: string | null;
      created_at: string;
      updated_at: string;
      closed_by?: components["schemas"]["simple-user"] | null;
      body_html?: string;
      body_text?: string;
      timeline_url?: string;
      repository?: components["schemas"]["repository"];
      performed_via_github_app?: components["schemas"]["integration"] | null;
      author_association: components["schemas"]["author_association"];
      reactions?: components["schemas"]["reaction-rollup"];
    };
    /** Api Overview */
    "api-overview": {
      verifiable_password_authentication: boolean;
      packages?: string[];
      dependabot?: string[];
      installed_version?: string;
    };
    /** Org Hook */
    "org-hook": {
      id: number;
      url: string;
      ping_url: string;
      name: string;
      events: string[];
      active: boolean;
      config: {
        url?: string;
        insecure_ssl?: string;
        content_type?: string;
        secret?: string;
      };
      updated_at: string;
      created_at: string;
      type: string;
    };
    "org-pre-receive-hook": {
      id?: number;
      name?: string;
      enforcement?: string;
      configuration_url?: string;
      allow_downstream_configuration?: boolean;
    };
    /** A team's access to a repository. */
    "team-repository": {
      /** Unique identifier of the repository */
      id: number;
      node_id: string;
      /** The name of the repository. */
      name: string;
      full_name: string;
      license: components["schemas"]["license-simple"] | null;
      forks: number;
      permissions?: {
        admin: boolean;
        pull: boolean;
        triage?: boolean;
        push: boolean;
        maintain?: boolean;
      };
      owner: components["schemas"]["simple-user"] | null;
      /** Whether the repository is private or public. */
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      /** The default branch of the repository. */
      default_branch: string;
      open_issues_count: number;
      /** Whether this repository acts as a template that can be used to generate new repositories. */
      is_template?: boolean;
      topics?: string[];
      /** Whether issues are enabled. */
      has_issues: boolean;
      /** Whether projects are enabled. */
      has_projects: boolean;
      /** Whether the wiki is enabled. */
      has_wiki: boolean;
      has_pages: boolean;
      /** Whether downloads are enabled. */
      has_downloads: boolean;
      /** Whether the repository is archived. */
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string | null;
      created_at: string | null;
      updated_at: string | null;
      /** Whether to allow rebase merges for pull requests. */
      allow_rebase_merge?: boolean;
      template_repository?: components["schemas"]["repository"] | null;
      temp_clone_token?: string;
      /** Whether to allow squash merges for pull requests. */
      allow_squash_merge?: boolean;
      /** Whether to delete head branches when pull requests are merged */
      delete_branch_on_merge?: boolean;
      /** Whether to allow merge commits for pull requests. */
      allow_merge_commit?: boolean;
      subscribers_count?: number;
      network_count?: number;
      open_issues: number;
      watchers: number;
      master_branch?: string;
    };
    /** Full Repository */
    "full-repository": {
      id: number;
      node_id: string;
      name: string;
      full_name: string;
      owner: components["schemas"]["simple-user"];
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url: string;
      mirror_url: string | null;
      hooks_url: string;
      svn_url: string;
      homepage: string | null;
      language: string | null;
      forks_count: number;
      stargazers_count: number;
      watchers_count: number;
      size: number;
      default_branch: string;
      open_issues_count: number;
      is_template?: boolean;
      topics?: string[];
      has_issues: boolean;
      has_projects: boolean;
      has_wiki: boolean;
      has_pages: boolean;
      has_downloads: boolean;
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      /** The repository visibility: public, private, or internal. */
      visibility?: string;
      pushed_at: string;
      created_at: string;
      updated_at: string;
      permissions?: {
        admin: boolean;
        maintain?: boolean;
        push: boolean;
        triage?: boolean;
        pull: boolean;
      };
      allow_rebase_merge?: boolean;
      template_repository?: components["schemas"]["repository"] | null;
      temp_clone_token?: string | null;
      allow_squash_merge?: boolean;
      delete_branch_on_merge?: boolean;
      allow_merge_commit?: boolean;
      subscribers_count: number;
      network_count: number;
      license: components["schemas"]["license-simple"] | null;
      organization?: components["schemas"]["simple-user"] | null;
      parent?: components["schemas"]["repository"];
      source?: components["schemas"]["repository"];
      forks: number;
      master_branch?: string;
      open_issues: number;
      watchers: number;
      /** Whether anonymous git access is allowed. */
      anonymous_access_enabled?: boolean;
      code_of_conduct?: components["schemas"]["code-of-conduct-simple"];
    };
    "code-scanning-alert": {
      number: components["schemas"]["alert-number"];
      created_at: components["schemas"]["alert-created-at"];
      url: components["schemas"]["alert-url"];
      html_url: components["schemas"]["alert-html-url"];
      instances?: { [key: string]: unknown };
      instances_url: components["schemas"]["alert-instances-url"];
      state: components["schemas"]["code-scanning-alert-state"];
      dismissed_by: components["schemas"]["simple-user"];
      dismissed_at: components["schemas"]["code-scanning-alert-dismissed-at"];
      dismissed_reason: components["schemas"]["code-scanning-alert-dismissed-reason"];
      rule: components["schemas"]["code-scanning-alert-rule"];
      tool: components["schemas"]["code-scanning-analysis-tool"];
      most_recent_instance: components["schemas"]["code-scanning-alert-instance"];
    };
    /** Pull Request Simple */
    "pull-request-simple": {
      url: string;
      id: number;
      node_id: string;
      html_url: string;
      diff_url: string;
      patch_url: string;
      issue_url: string;
      commits_url: string;
      review_comments_url: string;
      review_comment_url: string;
      comments_url: string;
      statuses_url: string;
      number: number;
      state: string;
      locked: boolean;
      title: string;
      user: components["schemas"]["simple-user"] | null;
      body: string | null;
      labels: {
        id?: number;
        node_id?: string;
        url?: string;
        name?: string;
        description?: string;
        color?: string;
        default?: boolean;
      }[];
      milestone: components["schemas"]["milestone"] | null;
      active_lock_reason?: string | null;
      created_at: string;
      updated_at: string;
      closed_at: string | null;
      merged_at: string | null;
      merge_commit_sha: string | null;
      assignee: components["schemas"]["simple-user"] | null;
      assignees?: components["schemas"]["simple-user"][] | null;
      requested_reviewers?: components["schemas"]["simple-user"][] | null;
      requested_teams?: components["schemas"]["team"][] | null;
      head: {
        label: string;
        ref: string;
        repo: components["schemas"]["repository"];
        sha: string;
        user: components["schemas"]["simple-user"] | null;
      };
      base: {
        label: string;
        ref: string;
        repo: components["schemas"]["repository"];
        sha: string;
        user: components["schemas"]["simple-user"] | null;
      };
      _links: {
        comments: components["schemas"]["link"];
        commits: components["schemas"]["link"];
        statuses: components["schemas"]["link"];
        html: components["schemas"]["link"];
        issue: components["schemas"]["link"];
        review_comments: components["schemas"]["link"];
        review_comment: components["schemas"]["link"];
        self: components["schemas"]["link"];
      };
      author_association: components["schemas"]["author_association"];
      auto_merge: components["schemas"]["auto_merge"];
      /** Indicates whether or not the pull request is a draft. */
      draft?: boolean;
    };
    /** Commit Comparison */
    "commit-comparison": {
      url: string;
      html_url: string;
      permalink_url: string;
      diff_url: string;
      patch_url: string;
      base_commit: components["schemas"]["commit"];
      merge_base_commit: components["schemas"]["commit"];
      status: "diverged" | "ahead" | "behind" | "identical";
      ahead_by: number;
      behind_by: number;
      total_commits: number;
      commits: components["schemas"]["commit"][];
      files?: components["schemas"]["diff-entry"][];
    };
    /** Webhooks for repositories. */
    hook: {
      type: string;
      /** Unique identifier of the webhook. */
      id: number;
      /** The name of a valid service, use 'web' for a webhook. */
      name: string;
      /** Determines whether the hook is actually triggered on pushes. */
      active: boolean;
      /** Determines what events the hook is triggered for. Default: ['push']. */
      events: string[];
      config: {
        email?: string;
        password?: string;
        room?: string;
        subdomain?: string;
        url?: components["schemas"]["webhook-config-url"];
        insecure_ssl?: components["schemas"]["webhook-config-insecure-ssl"];
        content_type?: components["schemas"]["webhook-config-content-type"];
        digest?: string;
        secret?: components["schemas"]["webhook-config-secret"];
        token?: string;
      };
      updated_at: string;
      created_at: string;
      url: string;
      test_url: string;
      ping_url: string;
      last_response: components["schemas"]["hook-response"];
    };
    /** Issue Simple */
    "issue-simple": {
      id: number;
      node_id: string;
      url: string;
      repository_url: string;
      labels_url: string;
      comments_url: string;
      events_url: string;
      html_url: string;
      number: number;
      state: string;
      title: string;
      body?: string;
      user: components["schemas"]["simple-user"] | null;
      labels: components["schemas"]["label"][];
      assignee: components["schemas"]["simple-user"] | null;
      assignees?: components["schemas"]["simple-user"][] | null;
      milestone: components["schemas"]["milestone"] | null;
      locked: boolean;
      active_lock_reason?: string | null;
      comments: number;
      pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
      };
      closed_at: string | null;
      created_at: string;
      updated_at: string;
      author_association: components["schemas"]["author_association"];
      body_html?: string;
      body_text?: string;
      timeline_url?: string;
      repository?: components["schemas"]["repository"];
      performed_via_github_app?: components["schemas"]["integration"] | null;
    };
    /** Issue Event */
    "issue-event": {
      id: number;
      node_id: string;
      url: string;
      actor: components["schemas"]["simple-user"] | null;
      event: string;
      commit_id: string | null;
      commit_url: string | null;
      created_at: string;
      issue?: components["schemas"]["issue-simple"];
      label?: components["schemas"]["issue-event-label"];
      assignee?: components["schemas"]["simple-user"] | null;
      assigner?: components["schemas"]["simple-user"] | null;
      review_requester?: components["schemas"]["simple-user"] | null;
      requested_reviewer?: components["schemas"]["simple-user"] | null;
      requested_team?: components["schemas"]["team"];
      dismissed_review?: components["schemas"]["issue-event-dismissed-review"];
      milestone?: components["schemas"]["issue-event-milestone"];
      project_card?: components["schemas"]["issue-event-project-card"];
      rename?: components["schemas"]["issue-event-rename"];
      author_association?: components["schemas"]["author_association"];
      lock_reason?: string | null;
      performed_via_github_app?: components["schemas"]["integration"] | null;
    };
    "repository-pre-receive-hook": {
      id?: number;
      name?: string;
      enforcement?: string;
      configuration_url?: string;
    };
    /** A release. */
    release: {
      url: string;
      html_url: string;
      assets_url: string;
      upload_url: string;
      tarball_url: string | null;
      zipball_url: string | null;
      id: number;
      node_id: string;
      /** The name of the tag. */
      tag_name: string;
      /** Specifies the commitish value that determines where the Git tag is created from. */
      target_commitish: string;
      name: string | null;
      body?: string | null;
      /** true to create a draft (unpublished) release, false to create a published one. */
      draft: boolean;
      /** Whether to identify the release as a prerelease or a full release. */
      prerelease: boolean;
      created_at: string;
      published_at: string | null;
      author: components["schemas"]["simple-user"];
      assets: components["schemas"]["release-asset"][];
      body_html?: string;
      body_text?: string;
      reactions?: components["schemas"]["reaction-rollup"];
    };
    /** Minimal Repository */
    "minimal-repository": {
      id: number;
      node_id: string;
      name: string;
      full_name: string;
      owner: components["schemas"]["simple-user"];
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      archive_url: string;
      assignees_url: string;
      blobs_url: string;
      branches_url: string;
      collaborators_url: string;
      comments_url: string;
      commits_url: string;
      compare_url: string;
      contents_url: string;
      contributors_url: string;
      deployments_url: string;
      downloads_url: string;
      events_url: string;
      forks_url: string;
      git_commits_url: string;
      git_refs_url: string;
      git_tags_url: string;
      git_url?: string;
      issue_comment_url: string;
      issue_events_url: string;
      issues_url: string;
      keys_url: string;
      labels_url: string;
      languages_url: string;
      merges_url: string;
      milestones_url: string;
      notifications_url: string;
      pulls_url: string;
      releases_url: string;
      ssh_url?: string;
      stargazers_url: string;
      statuses_url: string;
      subscribers_url: string;
      subscription_url: string;
      tags_url: string;
      teams_url: string;
      trees_url: string;
      clone_url?: string;
      mirror_url?: string | null;
      hooks_url: string;
      svn_url?: string;
      homepage?: string | null;
      language?: string | null;
      forks_count?: number;
      stargazers_count?: number;
      watchers_count?: number;
      size?: number;
      default_branch?: string;
      open_issues_count?: number;
      is_template?: boolean;
      topics?: string[];
      has_issues?: boolean;
      has_projects?: boolean;
      has_wiki?: boolean;
      has_pages?: boolean;
      has_downloads?: boolean;
      archived?: boolean;
      disabled?: boolean;
      visibility?: string;
      pushed_at?: string | null;
      created_at?: string | null;
      updated_at?: string | null;
      permissions?: {
        admin?: boolean;
        maintain?: boolean;
        push?: boolean;
        triage?: boolean;
        pull?: boolean;
      };
      template_repository?: components["schemas"]["repository"] | null;
      temp_clone_token?: string;
      delete_branch_on_merge?: boolean;
      subscribers_count?: number;
      network_count?: number;
      code_of_conduct?: components["schemas"]["code-of-conduct"];
      license?: {
        key?: string;
        name?: string;
        spdx_id?: string;
        url?: string;
        node_id?: string;
      } | null;
      forks?: number;
      open_issues?: number;
      watchers?: number;
    };
    /** Issue Search Result Item */
    "issue-search-result-item": {
      url: string;
      repository_url: string;
      labels_url: string;
      comments_url: string;
      events_url: string;
      html_url: string;
      id: number;
      node_id: string;
      number: number;
      title: string;
      locked: boolean;
      active_lock_reason?: string | null;
      assignees?: components["schemas"]["simple-user"][] | null;
      user: components["schemas"]["simple-user"] | null;
      labels: {
        id?: number;
        node_id?: string;
        url?: string;
        name?: string;
        color?: string;
        default?: boolean;
        description?: string | null;
      }[];
      state: string;
      assignee: components["schemas"]["simple-user"] | null;
      milestone: components["schemas"]["milestone"] | null;
      comments: number;
      created_at: string;
      updated_at: string;
      closed_at: string | null;
      text_matches?: components["schemas"]["search-result-text-matches"];
      pull_request?: {
        merged_at?: string | null;
        diff_url: string | null;
        html_url: string | null;
        patch_url: string | null;
        url: string | null;
      };
      body?: string;
      score: number;
      author_association: components["schemas"]["author_association"];
      draft?: boolean;
      repository?: components["schemas"]["repository"];
      body_html?: string;
      body_text?: string;
      timeline_url?: string;
      performed_via_github_app?: components["schemas"]["integration"] | null;
    };
    /** Repo Search Result Item */
    "repo-search-result-item": {
      id: number;
      node_id: string;
      name: string;
      full_name: string;
      owner: components["schemas"]["simple-user"] | null;
      private: boolean;
      html_url: string;
      description: string | null;
      fork: boolean;
      url: string;
      created_at: string;
      updated_at: string;
      pushed_at: string;
      homepage: string | null;
      size: number;
      stargazers_count: number;
      watchers_count: number;
      language: string | null;
      forks_count: number;
      open_issues_count: number;
      master_branch?: string;
      default_branch: string;
      score: number;
      forks_url: string;
      keys_url: string;
      collaborators_url: string;
      teams_url: string;
      hooks_url: string;
      issue_events_url: string;
      events_url: string;
      assignees_url: string;
      branches_url: string;
      tags_url: string;
      blobs_url: string;
      git_tags_url: string;
      git_refs_url: string;
      trees_url: string;
      statuses_url: string;
      languages_url: string;
      stargazers_url: string;
      contributors_url: string;
      subscribers_url: string;
      subscription_url: string;
      commits_url: string;
      git_commits_url: string;
      comments_url: string;
      issue_comment_url: string;
      contents_url: string;
      compare_url: string;
      merges_url: string;
      archive_url: string;
      downloads_url: string;
      issues_url: string;
      pulls_url: string;
      milestones_url: string;
      notifications_url: string;
      labels_url: string;
      releases_url: string;
      deployments_url: string;
      git_url: string;
      ssh_url: string;
      clone_url: string;
      svn_url: string;
      forks: number;
      open_issues: number;
      watchers: number;
      topics?: string[];
      mirror_url: string | null;
      has_issues: boolean;
      has_projects: boolean;
      has_pages: boolean;
      has_wiki: boolean;
      has_downloads: boolean;
      archived: boolean;
      /** Returns whether or not this repository disabled. */
      disabled: boolean;
      license: components["schemas"]["license-simple"] | null;
      permissions?: {
        admin: boolean;
        maintain?: boolean;
        push: boolean;
        triage?: boolean;
        pull: boolean;
      };
      text_matches?: components["schemas"]["search-result-text-matches"];
      temp_clone_token?: string;
      allow_merge_commit?: boolean;
      allow_squash_merge?: boolean;
      allow_rebase_merge?: boolean;
      delete_branch_on_merge?: boolean;
    };
    "configuration-status": {
      status?: string;
      progress?: {
        status: string;
        key: string;
      }[];
    };
    "maintenance-status": {
      status?: string;
      scheduled_time?: string;
      connection_services?: {
        name: string;
        number: number;
      }[];
    };
    "enterprise-settings": {
      enterprise?: {
        private_mode?: boolean;
        public_pages?: boolean;
        subdomain_isolation?: boolean;
        signup_enabled?: boolean;
        github_hostname?: string;
        identicons_host?: string;
        http_proxy?: string | null;
        auth_mode?: string;
        expire_sessions?: boolean;
        admin_password?: string | null;
        configuration_id?: number;
        configuration_run_count?: number;
        avatar?: {
          enabled?: boolean;
          uri?: string;
        };
        customer?: {
          name?: string;
          email?: string;
          uuid?: string;
          secret_key_data?: string;
          public_key_data?: string;
        };
        license?: {
          seats?: number;
          evaluation?: boolean;
          perpetual?: boolean;
          unlimited_seating?: boolean;
          support_key?: string;
          ssh_allowed?: boolean;
          cluster_support?: boolean;
          expire_at?: string;
        };
        github_ssl?: {
          enabled?: boolean;
          cert?: string | null;
          key?: string | null;
        };
        ldap?: {
          host?: string | null;
          port?: number;
          base?: { [key: string]: unknown }[];
          uid?: string | null;
          bind_dn?: string | null;
          password?: string | null;
          method?: string;
          search_strategy?: string;
          user_groups?: { [key: string]: unknown }[];
          admin_group?: string | null;
          virtual_attribute_enabled?: boolean;
          recursive_group_search?: boolean;
          posix_support?: boolean;
          user_sync_emails?: boolean;
          user_sync_keys?: boolean;
          user_sync_interval?: number;
          team_sync_interval?: number;
          sync_enabled?: boolean;
          reconciliation?: {
            user?: string | null;
            org?: string | null;
          };
          profile?: {
            uid?: string;
            name?: string | null;
            mail?: string | null;
            key?: string | null;
          };
        };
        cas?: {
          url?: string | null;
        };
        saml?: {
          sso_url?: string | null;
          certificate?: string | null;
          certificate_path?: string | null;
          issuer?: string | null;
          idp_initiated_sso?: boolean;
          disable_admin_demote?: boolean;
        };
        github_oauth?: {
          client_id?: string;
          client_secret?: string;
          organization_name?: string;
          organization_team?: string;
        };
        smtp?: {
          enabled?: boolean;
          address?: string;
          authentication?: string;
          port?: string;
          domain?: string;
          username?: string;
          user_name?: string;
          enable_starttls_auto?: boolean;
          password?: string;
          "discard-to-noreply-address"?: boolean;
          support_address?: string;
          support_address_type?: string;
          noreply_address?: string;
        };
        ntp?: {
          primary_server?: string;
          secondary_server?: string;
        };
        timezone?: string | null;
        snmp?: {
          enabled?: boolean;
          community?: string;
        };
        syslog?: {
          enabled?: boolean;
          server?: string | null;
          protocol_name?: string;
        };
        assets?: string | null;
        pages?: {
          enabled?: boolean;
        };
        collectd?: {
          enabled?: boolean;
          server?: string | null;
          port?: number;
          encryption?: string | null;
          username?: string | null;
          password?: string | null;
        };
        mapping?: {
          enabled?: boolean;
          tileserver?: string | null;
          basemap?: string;
          token?: string | null;
        };
        load_balancer?: string | null;
      };
      run_list?: string[];
    };
    "ssh-key": {
      key?: string;
      "pretty-print"?: string;
    };
    /** Starred Repository */
    "starred-repository": {
      starred_at: string;
      repo: components["schemas"]["repository"];
    };
    "scoped-installation": {
      permissions: components["schemas"]["app-permissions"];
      /** Describe whether all repositories have been selected or there's a selection involved */
      repository_selection: "all" | "selected";
      single_file_name: string | null;
      has_multiple_single_files?: boolean;
      single_file_paths?: string[];
      repositories_url: string;
      account: components["schemas"]["simple-user"];
    };
    /** The permissions granted to the user-to-server access token. */
    "app-permissions": {
      /** The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts. Can be one of: `read` or `write`. */
      actions?: "read" | "write";
      /** The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation. Can be one of: `read` or `write`. */
      administration?: "read" | "write";
      /** The level of permission to grant the access token for checks on code. Can be one of: `read` or `write`. */
      checks?: "read" | "write";
      /** The level of permission to grant the access token for notification of content references and creation content attachments. Can be one of: `read` or `write`. */
      content_references?: "read" | "write";
      /** The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges. Can be one of: `read` or `write`. */
      contents?: "read" | "write";
      /** The level of permission to grant the access token for deployments and deployment statuses. Can be one of: `read` or `write`. */
      deployments?: "read" | "write";
      /** The level of permission to grant the access token for managing repository environments. Can be one of: `read` or `write`. */
      environments?: "read" | "write";
      /** The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones. Can be one of: `read` or `write`. */
      issues?: "read" | "write";
      /** The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata. Can be one of: `read` or `write`. */
      metadata?: "read" | "write";
      /** The level of permission to grant the access token for packages published to GitHub Packages. Can be one of: `read` or `write`. */
      packages?: "read" | "write";
      /** The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds. Can be one of: `read` or `write`. */
      pages?: "read" | "write";
      /** The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges. Can be one of: `read` or `write`. */
      pull_requests?: "read" | "write";
      /** The level of permission to grant the access token to manage the post-receive hooks for a repository. Can be one of: `read` or `write`. */
      repository_hooks?: "read" | "write";
      /** The level of permission to grant the access token to manage repository projects, columns, and cards. Can be one of: `read`, `write`, or `admin`. */
      repository_projects?: "read" | "write" | "admin";
      /** The level of permission to grant the access token to view and manage secret scanning alerts. Can be one of: `read` or `write`. */
      secret_scanning_alerts?: "read" | "write";
      /** The level of permission to grant the access token to manage repository secrets. Can be one of: `read` or `write`. */
      secrets?: "read" | "write";
      /** The level of permission to grant the access token to view and manage security events like code scanning alerts. Can be one of: `read` or `write`. */
      security_events?: "read" | "write";
      /** The level of permission to grant the access token to manage just a single file. Can be one of: `read` or `write`. */
      single_file?: "read" | "write";
      /** The level of permission to grant the access token for commit statuses. Can be one of: `read` or `write`. */
      statuses?: "read" | "write";
      /** The level of permission to grant the access token to retrieve Dependabot alerts. Can be one of: `read`. */
      vulnerability_alerts?: "read";
      /** The level of permission to grant the access token to update GitHub Actions workflow files. Can be one of: `write`. */
      workflows?: "write";
      /** The level of permission to grant the access token for organization teams and members. Can be one of: `read` or `write`. */
      members?: "read" | "write";
      /** The level of permission to grant the access token to manage access to an organization. Can be one of: `read` or `write`. */
      organization_administration?: "read" | "write";
      /** The level of permission to grant the access token to manage the post-receive hooks for an organization. Can be one of: `read` or `write`. */
      organization_hooks?: "read" | "write";
      /** The level of permission to grant the access token for viewing an organization's plan. Can be one of: `read`. */
      organization_plan?: "read";
      /** The level of permission to grant the access token to manage organization projects, columns, and cards. Can be one of: `read`, `write`, or `admin`. */
      organization_projects?: "read" | "write" | "admin";
      /** The level of permission to grant the access token for organization packages published to GitHub Packages. Can be one of: `read` or `write`. */
      organization_packages?: "read" | "write";
      /** The level of permission to grant the access token to manage organization secrets. Can be one of: `read` or `write`. */
      organization_secrets?: "read" | "write";
      /** The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization. Can be one of: `read` or `write`. */
      organization_self_hosted_runners?: "read" | "write";
      /** The level of permission to grant the access token to view and manage users blocked by the organization. Can be one of: `read` or `write`. */
      organization_user_blocking?: "read" | "write";
      /** The level of permission to grant the access token to manage team discussions and related comments. Can be one of: `read` or `write`. */
      team_discussions?: "read" | "write";
    };
    /** Basic Error */
    "basic-error": {
      message?: string;
      documentation_url?: string;
      url?: string;
      status?: string;
    };
    /** The announcement text in GitHub Flavored Markdown. For more information about GitHub Flavored Markdown, see "[Mastering markdown](https://guides.github.com/features/mastering-markdown/)." */
    "announcement-message": string;
    /** The time at which the announcement expires. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. To set an announcement that never expires, omit this parameter, set it to `null`, or set it to an empty string. */
    "announcement-expiration": string | null;
    /** Actor */
    actor: {
      id: number;
      login: string;
      display_login?: string;
      gravatar_id: string | null;
      url: string;
      avatar_url: string;
    };
    /** Comments provide a way for people to collaborate on an issue. */
    "issue-comment": {
      /** Unique identifier of the issue comment */
      id: number;
      node_id: string;
      /** URL for the issue comment */
      url: string;
      /** Contents of the issue comment */
      body?: string;
      body_text?: string;
      body_html?: string;
      html_url: string;
      user: components["schemas"]["simple-user"] | null;
      created_at: string;
      updated_at: string;
      issue_url: string;
      author_association: components["schemas"]["author_association"];
      performed_via_github_app?: components["schemas"]["integration"] | null;
      reactions?: components["schemas"]["reaction-rollup"];
    };
    /** How the author is associated with the repository. */
    author_association:
      | "COLLABORATOR"
      | "CONTRIBUTOR"
      | "FIRST_TIMER"
      | "FIRST_TIME_CONTRIBUTOR"
      | "MANNEQUIN"
      | "MEMBER"
      | "NONE"
      | "OWNER";
    /** GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub. */
    integration: {
      /** Unique identifier of the GitHub app */
      id: number;
      /** The slug name of the GitHub app */
      slug?: string;
      node_id: string;
      owner: components["schemas"]["simple-user"] | null;
      /** The name of the GitHub app */
      name: string;
      description: string | null;
      external_url: string;
      html_url: string;
      created_at: string;
      updated_at: string;
      /** The set of permissions for the GitHub app */
      permissions: {
        issues?: string;
        checks?: string;
        metadata?: string;
        contents?: string;
        deployments?: string;
      } & { [key: string]: string };
      /** The list of events for the GitHub app */
      events: string[];
      /** The number of installations associated with the GitHub app */
      installations_count?: number;
      client_id?: string;
      client_secret?: string;
      webhook_secret?: string | null;
      pem?: string;
    } | null;
    "reaction-rollup": {
      url: string;
      total_count: number;
      "+1": number;
      "-1": number;
      laugh: number;
      confused: number;
      heart: number;
      hooray: number;
      eyes: number;
      rocket: number;
    };
    /** License Simple */
    "license-simple": {
      key: string;
      name: string;
      url: string | null;
      spdx_id: string | null;
      node_id: string;
      html_url?: string;
    };
    /** A collection of related issues and pull requests. */
    milestone: {
      url: string;
      html_url: string;
      labels_url: string;
      id: number;
      node_id: string;
      /** The number of the milestone. */
      number: number;
      /** The state of the milestone. */
      state: "open" | "closed";
      /** The title of the milestone. */
      title: string;
      description: string | null;
      creator: components["schemas"]["simple-user"] | null;
      open_issues: number;
      closed_issues: number;
      created_at: string;
      updated_at: string;
      closed_at: string | null;
      due_on: string | null;
    };
    /** Validation Error */
    "validation-error": {
      message: string;
      documentation_url: string;
      errors?: {
        resource?: string;
        field?: string;
        message?: string;
        code: string;
        index?: number;
        value?: (string | null) | (number | null) | (string[] | null);
      }[];
    };
    /** Code of Conduct Simple */
    "code-of-conduct-simple": {
      url: string;
      key: string;
      name: string;
      html_url: string | null;
    };
    /** The security alert number. */
    "alert-number": number;
    /** The time that the alert was created in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
    "alert-created-at": string;
    /** The REST API URL of the alert resource. */
    "alert-url": string;
    /** The GitHub URL of the alert resource. */
    "alert-html-url": string;
    /** The REST API URL for fetching the list of instances for an alert. */
    "alert-instances-url": string;
    /** State of a code scanning alert. */
    "code-scanning-alert-state": "open" | "closed" | "dismissed" | "fixed";
    /** The time that the alert was dismissed in ISO 8601 format: `YYYY-MM-DDTHH:MM:SSZ`. */
    "code-scanning-alert-dismissed-at": string | null;
    /** **Required when the state is dismissed.** The reason for dismissing or closing the alert. Can be one of: `false positive`, `won't fix`, and `used in tests`. */
    "code-scanning-alert-dismissed-reason":
      | ("false positive" | "won't fix" | "used in tests")
      | null;
    "code-scanning-alert-rule": {
      /** A unique identifier for the rule used to detect the alert. */
      id?: string | null;
      /** The name of the rule used to detect the alert. */
      name?: string;
      /** The severity of the alert. */
      severity?: ("none" | "note" | "warning" | "error") | null;
      /** A short description of the rule used to detect the alert. */
      description?: string;
      /** description of the rule used to detect the alert. */
      full_description?: string;
      /** A set of tags applicable for the rule. */
      tags?: string[] | null;
      /** Detailed documentation for the rule as GitHub Flavored Markdown. */
      help?: string | null;
    };
    "code-scanning-analysis-tool": {
      name?: components["schemas"]["code-scanning-analysis-tool-name"];
      version?: components["schemas"]["code-scanning-analysis-tool-version"];
      guid?: components["schemas"]["code-scanning-analysis-tool-guid"];
    };
    /** The name of the tool used to generate the code scanning analysis. */
    "code-scanning-analysis-tool-name": string;
    /** The version of the tool used to generate the code scanning analysis. */
    "code-scanning-analysis-tool-version": string | null;
    /** The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data. */
    "code-scanning-analysis-tool-guid": string | null;
    "code-scanning-alert-instance": {
      ref?: components["schemas"]["code-scanning-ref"];
      analysis_key?: components["schemas"]["code-scanning-analysis-analysis-key"];
      environment?: components["schemas"]["code-scanning-alert-environment"];
      state?: components["schemas"]["code-scanning-alert-state"];
      commit_sha?: string;
      message?: {
        text?: string;
      };
      location?: components["schemas"]["code-scanning-alert-location"];
      html_url?: string;
      /**
       * Classifications that have been applied to the file that triggered the alert.
       * For example identifying it as documentation, or a generated file.
       */
      classifications?: components["schemas"]["code-scanning-alert-classification"][];
    };
    /**
     * The full Git reference, formatted as `refs/heads/<branch name>`,
     * `refs/pull/<number>/merge`, or `refs/pull/<number>/head`.
     */
    "code-scanning-ref": string;
    /** Identifies the configuration under which the analysis was executed. For example, in GitHub Actions this includes the workflow filename and job name. */
    "code-scanning-analysis-analysis-key": string;
    /** Identifies the variable values associated with the environment in which the analysis that generated this alert instance was performed, such as the language that was analyzed. */
    "code-scanning-alert-environment": string;
    /** Describe a region within a file for the alert. */
    "code-scanning-alert-location": {
      path?: string;
      start_line?: number;
      end_line?: number;
      start_column?: number;
      end_column?: number;
    };
    /** A classification of the file. For example to identify it as generated. */
    "code-scanning-alert-classification":
      | ("source" | "generated" | "test" | "library")
      | null;
    /** Groups of organization members that gives permissions on specified repositories. */
    team: {
      id: number;
      node_id: string;
      name: string;
      slug: string;
      description: string | null;
      privacy?: string;
      permission: string;
      permissions?: {
        pull: boolean;
        triage: boolean;
        push: boolean;
        maintain: boolean;
        admin: boolean;
      };
      url: string;
      html_url: string;
      members_url: string;
      repositories_url: string;
      parent: components["schemas"]["team-simple"] | null;
    };
    /** Groups of organization members that gives permissions on specified repositories. */
    "team-simple": {
      /** Unique identifier of the team */
      id: number;
      node_id: string;
      /** URL for the team */
      url: string;
      members_url: string;
      /** Name of the team */
      name: string;
      /** Description of the team */
      description: string | null;
      /** Permission that the team will have for its repositories */
      permission: string;
      /** The level of privacy this team should have */
      privacy?: string;
      html_url: string;
      repositories_url: string;
      slug: string;
      /** Distinguished Name (DN) that team maps to within LDAP environment */
      ldap_dn?: string;
    } | null;
    /** Hypermedia Link */
    link: {
      href: string;
    };
    /** The status of auto merging a pull request. */
    auto_merge: {
      enabled_by: components["schemas"]["simple-user"];
      /** The merge method to use. */
      merge_method: "merge" | "squash" | "rebase";
      /** Title for the merge commit message. */
      commit_title: string;
      /** Commit message for the merge commit. */
      commit_message: string;
    } | null;
    /** Commit */
    commit: {
      url: string;
      sha: string;
      node_id: string;
      html_url: string;
      comments_url: string;
      commit: {
        url: string;
        author: components["schemas"]["git-user"] | null;
        committer: components["schemas"]["git-user"] | null;
        message: string;
        comment_count: number;
        tree: {
          sha: string;
          url: string;
        };
        verification?: components["schemas"]["verification"];
      };
      author: components["schemas"]["simple-user"] | null;
      committer: components["schemas"]["simple-user"] | null;
      parents: {
        sha: string;
        url: string;
        html_url?: string;
      }[];
      stats?: {
        additions?: number;
        deletions?: number;
        total?: number;
      };
      files?: {
        filename?: string;
        additions?: number;
        deletions?: number;
        changes?: number;
        status?: string;
        raw_url?: string;
        blob_url?: string;
        patch?: string;
        sha?: string;
        contents_url?: string;
        previous_filename?: string;
      }[];
    };
    /** Metaproperties for Git author/committer information. */
    "git-user": {
      name?: string;
      email?: string;
      date?: string;
    };
    verification: {
      verified: boolean;
      reason: string;
      payload: string | null;
      signature: string | null;
    };
    /** Diff Entry */
    "diff-entry": {
      sha: string;
      filename: string;
      status: string;
      additions: number;
      deletions: number;
      changes: number;
      blob_url: string;
      raw_url: string;
      contents_url: string;
      patch?: string;
      previous_filename?: string;
    };
    /** The URL to which the payloads will be delivered. */
    "webhook-config-url": string;
    "webhook-config-insecure-ssl": string | number;
    /** The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. */
    "webhook-config-content-type": string;
    /** If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#delivery-headers). */
    "webhook-config-secret": string;
    "hook-response": {
      code: number | null;
      status: string | null;
      message: string | null;
    };
    /** Color-coded labels help you categorize and filter your issues (just like labels in Gmail). */
    label: {
      id: number;
      node_id: string;
      /** URL for the label */
      url: string;
      /** The name of the label. */
      name: string;
      description: string | null;
      /** 6-character hex code, without the leading #, identifying the color */
      color: string;
      default: boolean;
    };
    /** Issue Event Label */
    "issue-event-label": {
      name: string | null;
      color: string | null;
    };
    "issue-event-dismissed-review": {
      state: string;
      review_id: number;
      dismissal_message: string | null;
      dismissal_commit_id?: string | null;
    };
    /** Issue Event Milestone */
    "issue-event-milestone": {
      title: string;
    };
    /** Issue Event Project Card */
    "issue-event-project-card": {
      url: string;
      id: number;
      project_url: string;
      project_id: number;
      column_name: string;
      previous_column_name?: string;
    };
    /** Issue Event Rename */
    "issue-event-rename": {
      from: string;
      to: string;
    };
    /** Data related to a release. */
    "release-asset": {
      url: string;
      browser_download_url: string;
      id: number;
      node_id: string;
      /** The file name of the asset. */
      name: string;
      label: string | null;
      /** State of the release asset. */
      state: "uploaded" | "open";
      content_type: string;
      size: number;
      download_count: number;
      created_at: string;
      updated_at: string;
      uploader: components["schemas"]["simple-user"] | null;
    };
    /** Code Of Conduct */
    "code-of-conduct": {
      key: string;
      name: string;
      url: string;
      body?: string;
      html_url: string | null;
    };
    "search-result-text-matches": {
      object_url?: string;
      object_type?: string | null;
      property?: string;
      fragment?: string;
      matches?: {
        text?: string;
        indices?: number[];
      }[];
    }[];
  };
  responses: {
    /** Resource not found */
    not_found: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Not modified */
    not_modified: unknown;
    /** Forbidden */
    forbidden: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Service unavailable */
    service_unavailable: {
      content: {
        "application/json": {
          code?: string;
          message?: string;
          documentation_url?: string;
        };
      };
    };
    /** Requires authentication */
    requires_authentication: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Validation failed */
    validation_failed: {
      content: {
        "application/json": components["schemas"]["validation-error"];
      };
    };
    /** Moved permanently */
    moved_permanently: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Response if GitHub Advanced Security is not enabled for this repository */
    code_scanning_forbidden_read: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Preview header missing */
    preview_header_missing: {
      content: {
        "application/json": {
          message: string;
          documentation_url: string;
        };
      };
    };
    /** Internal Error */
    internal_error: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
    /** Gone */
    gone: {
      content: {
        "application/json": components["schemas"]["basic-error"];
      };
    };
  };
  parameters: {
    /** Results per page (max 100) */
    "per-page": number;
    /** Page number of the results to fetch. */
    page: number;
    "hook-id": number;
    /** One of `asc` (ascending) or `desc` (descending). */
    direction: "asc" | "desc";
    "key-ids": string;
    "team-id": number;
    username: string;
    org: string;
    "pre-receive-environment-id": number;
    /** pre_receive_hook_id parameter */
    "pre-receive-hook-id": number;
    "token-id": number;
    /** The client ID of your GitHub app. */
    "client-id": string;
    "access-token": string;
    /** The slug version of the enterprise name. You can also substitute this value with the enterprise id. */
    enterprise: string;
    /** A list of comma separated label names. Example: `bug,ui,@high` */
    labels: string;
    /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
    since: string;
    owner: string;
    repo: string;
    /** team_slug parameter */
    "team-slug": string;
    /** The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation. */
    "alert-number": components["schemas"]["alert-number"];
    /** commit_sha parameter */
    "commit-sha": string;
    /** issue_number parameter */
    "issue-number": number;
    /** release_id parameter */
    "release-id": number;
    /** A repository ID. Only return repositories with an ID greater than this ID. */
    "since-repo": number;
    /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
    order: "desc" | "asc";
    /** installation_id parameter */
    "installation-id": number;
    /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
    before: string;
    /** One of `created` (when the repository was starred) or `updated` (when it was last pushed to). */
    sort: "created" | "updated";
  };
  headers: {
    link?: string;
  };
}

export interface operations {
  "enterprise-admin/list-global-webhooks": {
    parameters: {
      header: {
        /** This API is under preview and subject to change. */
        accept: string;
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["global-hook"][];
        };
      };
    };
  };
  "enterprise-admin/create-global-webhook": {
    parameters: {
      header: {
        /** This API is under preview and subject to change. */
        accept: string;
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["global-hook"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** Must be passed as "web". */
          name: string;
          /** Key/value pairs to provide settings for this webhook. */
          config: {
            /** The URL to which the payloads will be delivered. */
            url: string;
            /** The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. */
            content_type?: string;
            /** If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value in the [`X-Hub-Signature`](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#delivery-headers) header. */
            secret?: string;
            /** Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.** */
            insecure_ssl?: string;
          };
          /** The [events](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads) that trigger this webhook. A global webhook can be triggered by `user` and `organization` events. Default: `user` and `organization`. */
          events?: string[];
          /** Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. */
          active?: boolean;
        };
      };
    };
  };
  "enterprise-admin/get-global-webhook": {
    parameters: {
      header: {
        /** This API is under preview and subject to change. */
        accept: string;
      };
      path: {
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["global-hook"];
        };
      };
    };
  };
  "enterprise-admin/delete-global-webhook": {
    parameters: {
      header: {
        /** This API is under preview and subject to change. */
        accept: string;
      };
      path: {
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /** Parameters that are not provided will be overwritten with the default value or removed if no default exists. */
  "enterprise-admin/update-global-webhook": {
    parameters: {
      header: {
        /** This API is under preview and subject to change. */
        accept: string;
      };
      path: {
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["global-hook-2"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** Key/value pairs to provide settings for this webhook. */
          config?: {
            /** The URL to which the payloads will be delivered. */
            url: string;
            /** The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`. */
            content_type?: string;
            /** If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value in the [`X-Hub-Signature`](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#delivery-headers) header. */
            secret?: string;
            /** Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.** */
            insecure_ssl?: string;
          };
          /** The [events](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads) that trigger this webhook. A global webhook can be triggered by `user` and `organization` events. Default: `user` and `organization`. */
          events?: string[];
          /** Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications. */
          active?: boolean;
        };
      };
    };
  };
  /** This will trigger a [ping event](https://docs.github.com/enterprise-server@3.1/webhooks/#ping-event) to be sent to the webhook. */
  "enterprise-admin/ping-global-webhook": {
    parameters: {
      header: {
        /** This API is under preview and subject to change. */
        accept: string;
      };
      path: {
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  "enterprise-admin/list-public-keys": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        sort?: "created" | "updated" | "accessed";
        /** Only show public keys accessed after the given time. */
        since?: string;
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["public-key-full"][];
        };
      };
    };
  };
  "enterprise-admin/delete-public-key": {
    parameters: {
      path: {
        key_ids: components["parameters"]["key-ids"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /**
   * Updates the [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team. [LDAP synchronization](https://help.github.com/enterprise/admin/guides/user-management/using-ldap/#enabling-ldap-sync) must be enabled to map LDAP entries to a team. Use the [Create a team](https://docs.github.com/enterprise-server@3.1/rest/reference/teams/#create-a-team) endpoint to create a team with LDAP mapping.
   *
   * If you pass the `hellcat-preview` media type, you can also update the LDAP mapping of a child team.
   */
  "enterprise-admin/update-ldap-mapping-for-team": {
    parameters: {
      path: {
        team_id: components["parameters"]["team-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["ldap-mapping-team"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team. */
          ldap_dn?: string;
        };
      };
    };
  };
  /** Note that this API call does not automatically initiate an LDAP sync. Rather, if a `201` is returned, the sync job is queued successfully, and is performed when the instance is ready. */
  "enterprise-admin/sync-ldap-mapping-for-team": {
    parameters: {
      path: {
        team_id: components["parameters"]["team-id"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": {
            status?: string;
          };
        };
      };
    };
  };
  "enterprise-admin/update-ldap-mapping-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["ldap-mapping-user"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The [distinguished name](https://www.ldap.com/ldap-dns-and-rdns) (DN) of the LDAP entry to map to a team. */
          ldap_dn?: string;
        };
      };
    };
  };
  /** Note that this API call does not automatically initiate an LDAP sync. Rather, if a `201` is returned, the sync job is queued successfully, and is performed when the instance is ready. */
  "enterprise-admin/sync-ldap-mapping-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": {
            status?: string;
          };
        };
      };
    };
  };
  "enterprise-admin/create-org": {
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["organization-simple"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The organization's username. */
          login: string;
          /** The login of the user who will manage this organization. */
          admin: string;
          /** The organization's display name. */
          profile_name?: string;
        };
      };
    };
  };
  "enterprise-admin/update-org-name": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
    };
    responses: {
      /** Response */
      202: {
        content: {
          "application/json": {
            message?: string;
            url?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The organization's new name. */
          login: string;
        };
      };
    };
  };
  "enterprise-admin/list-pre-receive-environments": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        sort?: "created" | "updated" | "name";
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-environment"][];
        };
      };
    };
  };
  "enterprise-admin/create-pre-receive-environment": {
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["pre-receive-environment"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The new pre-receive environment's name. */
          name: string;
          /** URL from which to download a tarball of this environment. */
          image_url: string;
        };
      };
    };
  };
  "enterprise-admin/get-pre-receive-environment": {
    parameters: {
      path: {
        pre_receive_environment_id: components["parameters"]["pre-receive-environment-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-environment"];
        };
      };
    };
  };
  /**
   * If you attempt to delete an environment that cannot be deleted, you will receive a `422 Unprocessable Entity` response.
   *
   * The possible error messages are:
   *
   * *   _Cannot modify or delete the default environment_
   * *   _Cannot delete environment that has hooks_
   * *   _Cannot delete environment when download is in progress_
   */
  "enterprise-admin/delete-pre-receive-environment": {
    parameters: {
      path: {
        pre_receive_environment_id: components["parameters"]["pre-receive-environment-id"];
      };
    };
    responses: {
      /** Response */
      204: never;
      /** Client Errors */
      422: {
        content: {
          "application/json": {
            message?: string;
            errors?: {
              resource?: string;
              code?: string;
              message?: string;
            }[];
          };
        };
      };
    };
  };
  /** You cannot modify the default environment. If you attempt to modify the default environment, you will receive a `422 Unprocessable Entity` response. */
  "enterprise-admin/update-pre-receive-environment": {
    parameters: {
      path: {
        pre_receive_environment_id: components["parameters"]["pre-receive-environment-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-environment"];
        };
      };
      /** Client Errors */
      422: {
        content: {
          "application/json": {
            message?: string;
            errors?: {
              resource?: string;
              code?: string;
              message?: string;
            }[];
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** This pre-receive environment's new name. */
          name?: string;
          /** URL from which to download a tarball of this environment. */
          image_url?: string;
        };
      };
    };
  };
  /**
   * Triggers a new download of the environment tarball from the environment's `image_url`. When the download is finished, the newly downloaded tarball will overwrite the existing environment.
   *
   * If a download cannot be triggered, you will receive a `422 Unprocessable Entity` response.
   *
   * The possible error messages are:
   *
   * * _Cannot modify or delete the default environment_
   * * _Can not start a new download when a download is in progress_
   */
  "enterprise-admin/start-pre-receive-environment-download": {
    parameters: {
      path: {
        pre_receive_environment_id: components["parameters"]["pre-receive-environment-id"];
      };
    };
    responses: {
      /** Response */
      202: {
        content: {
          "application/json": components["schemas"]["pre-receive-environment-download-status"];
        };
      };
      /** Client Errors */
      422: {
        content: {
          "application/json": {
            message?: string;
            errors?: {
              resource?: string;
              code?: string;
              message?: string;
            }[];
          };
        };
      };
    };
  };
  /** In addition to seeing the download status at the "[Get a pre-receive environment](#get-a-pre-receive-environment)" endpoint, there is also this separate endpoint for just the download status. */
  "enterprise-admin/get-download-status-for-pre-receive-environment": {
    parameters: {
      path: {
        pre_receive_environment_id: components["parameters"]["pre-receive-environment-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-environment-download-status"];
        };
      };
    };
  };
  "enterprise-admin/list-pre-receive-hooks": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** One of `created` (when the repository was starred) or `updated` (when it was last pushed to) or `name`. */
        sort?: "created" | "updated" | "name";
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-hook"][];
        };
      };
    };
  };
  "enterprise-admin/create-pre-receive-hook": {
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["pre-receive-hook"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the hook. */
          name: string;
          /** The script that the hook runs. */
          script: string;
          /** The GitHub repository where the script is kept. */
          script_repository: { [key: string]: any };
          /** The pre-receive environment where the script is executed. */
          environment: { [key: string]: any };
          /** The state of enforcement for this hook. default: `disabled` */
          enforcement?: string;
          /** Whether enforcement can be overridden at the org or repo level. default: `false` */
          allow_downstream_configuration?: boolean;
        };
      };
    };
  };
  "enterprise-admin/get-pre-receive-hook": {
    parameters: {
      path: {
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-hook"];
        };
      };
    };
  };
  "enterprise-admin/delete-pre-receive-hook": {
    parameters: {
      path: {
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  "enterprise-admin/update-pre-receive-hook": {
    parameters: {
      path: {
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["pre-receive-hook"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The name of the hook. */
          name?: string;
          /** The script that the hook runs. */
          script?: string;
          /** The GitHub repository where the script is kept. */
          script_repository?: { [key: string]: any };
          /** The pre-receive environment where the script is executed. */
          environment?: { [key: string]: any };
          /** The state of enforcement for this hook. */
          enforcement?: string;
          /** Whether enforcement can be overridden at the org or repo level. */
          allow_downstream_configuration?: boolean;
        };
      };
    };
  };
  /** Lists personal access tokens for all users, including admin users. */
  "enterprise-admin/list-personal-access-tokens": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["authorization"][];
        };
      };
    };
  };
  /** Deletes a personal access token. Returns a `403 - Forbidden` status when a personal access token is in use. For example, if you access this endpoint with the same personal access token that you are trying to delete, you will receive this error. */
  "enterprise-admin/delete-personal-access-token": {
    parameters: {
      path: {
        token_id: components["parameters"]["token-id"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /**
   * If an external authentication mechanism is used, the login name should match the login name in the external system. If you are using LDAP authentication, you should also [update the LDAP mapping](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#update-ldap-mapping-for-a-user) for the user.
   *
   * The login name will be normalized to only contain alphanumeric characters or single hyphens. For example, if you send `"octo_cat"` as the login, a user named `"octo-cat"` will be created.
   *
   * If the login name or email address is already associated with an account, the server will return a `422` response.
   */
  "enterprise-admin/create-user": {
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["simple-user"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The user's username. */
          login: string;
          /** **Required for built-in authentication.** The user's email address. This parameter can be omitted when using CAS, LDAP, or SAML. For details on built-in and centrally-managed authentication, see the the [GitHub authentication guide](https://help.github.com/enterprise/2.18/admin/guides/user-management/authenticating-users-for-your-github-enterprise-server-instance/). */
          email?: string;
        };
      };
    };
  };
  /**
   * Deleting a user will delete all their repositories, gists, applications, and personal settings. [Suspending a user](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#suspend-a-user) is often a better option.
   *
   * You can delete any user account except your own.
   */
  "enterprise-admin/delete-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  "enterprise-admin/update-username-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      202: {
        content: {
          "application/json": {
            message?: string;
            url?: string;
          };
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The user's new username. */
          login: string;
        };
      };
    };
  };
  "enterprise-admin/create-impersonation-o-auth-token": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** A list of [scopes](https://docs.github.com/enterprise-server@3.1/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/). */
          scopes?: string[];
        };
      };
    };
  };
  "enterprise-admin/delete-impersonation-o-auth-token": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
   *
   * OAuth application owners can revoke a grant for their OAuth application and a specific user. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. You must also provide a valid token as `:access_token` and the grant for the token's owner will be deleted.
   *
   * Deleting an OAuth application's grant will also delete all OAuth tokens associated with the application for the user. Once deleted, the application will have no access to the user's account and will no longer be listed on [the Applications settings page under "Authorized OAuth Apps" on GitHub Enterprise Server](https://github.com/settings/applications#authorized).
   */
  "apps/revoke-grant-for-application": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        access_token: components["parameters"]["access-token"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
   *
   * OAuth applications can use a special API method for checking OAuth token validity without exceeding the normal rate limits for failed login attempts. Authentication works differently with this particular endpoint. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
   */
  "apps/check-authorization": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        access_token: components["parameters"]["access-token"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"] | null;
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
   *
   * OAuth applications can use this API method to reset a valid OAuth token without end-user involvement. Applications must save the "token" property in the response because changes take effect immediately. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password. Invalid tokens will return `404 NOT FOUND`.
   */
  "apps/reset-authorization": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        access_token: components["parameters"]["access-token"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["authorization"];
        };
      };
    };
  };
  /**
   * **Deprecation Notice:** GitHub Enterprise Server will discontinue OAuth endpoints that contain `access_token` in the path parameter. We have introduced new endpoints that allow you to securely manage tokens for OAuth Apps by moving `access_token` to the request body. For more information, see the [blog post](https://developer.github.com/changes/2020-02-14-deprecating-oauth-app-endpoint/).
   *
   * OAuth application owners can revoke a single token for an OAuth application. You must use [Basic Authentication](https://docs.github.com/enterprise-server@3.1/rest/overview/other-authentication-methods#basic-authentication) when accessing this endpoint, using the OAuth application's `client_id` and `client_secret` as the username and password.
   */
  "apps/revoke-authorization-for-application": {
    parameters: {
      path: {
        /** The client ID of your GitHub app. */
        client_id: components["parameters"]["client-id"];
        access_token: components["parameters"]["access-token"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /** Gets the current message and expiration date of the global announcement banner in your enterprise. */
  "enterprise-admin/get-announcement": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["announcement"];
        };
      };
    };
  };
  /** Removes the global announcement banner in your enterprise. */
  "enterprise-admin/remove-announcement": {
    responses: {
      /** Response */
      204: never;
    };
  };
  /** Sets the message and expiration time for the global announcement banner in your enterprise. */
  "enterprise-admin/set-announcement": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["announcement"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["announcement"];
      };
    };
  };
  "enterprise-admin/get-license-information": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["license-info"];
        };
      };
    };
  };
  "enterprise-admin/get-all-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-gist-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-comment-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-comment-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-hooks-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-hook-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-issue-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-issue-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-milestone-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-milestone-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-org-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-organization-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-pages-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-page-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-pull-request-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-pull-request-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-repo-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-repository-overview"];
        };
      };
    };
  };
  "enterprise-admin/get-user-stats": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-user-overview"];
        };
      };
    };
  };
  /**
   * Gets the selected actions that are allowed in an enterprise. To use this endpoint, the enterprise permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an enterprise](#set-github-actions-permissions-for-an-enterprise)."
   *
   * You must authenticate using an access token with the `admin:enterprise` scope to use this endpoint.
   */
  "enterprise-admin/get-allowed-actions-enterprise": {
    parameters: {
      path: {
        /** The slug version of the enterprise name. You can also substitute this value with the enterprise id. */
        enterprise: components["parameters"]["enterprise"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["selected-actions"];
        };
      };
    };
  };
  /** We delay the public events feed by five minutes, which means the most recent event returned by the public events API actually occurred at least five minutes ago. */
  "activity/list-public-events": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /**
   * List repositories that an app installation can access.
   *
   * You must use an [installation access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-an-installation) to access this endpoint.
   */
  "apps/list-repos-accessible-to-installation": {
    parameters: {
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            repositories: components["schemas"]["repository"][];
            repository_selection?: string;
          };
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /**
   * List issues assigned to the authenticated user across all visible repositories including owned repositories, member
   * repositories, and organization repositories. You can use the `filter` query parameter to fetch issues that are not
   * necessarily assigned to you.
   *
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list": {
    parameters: {
      query: {
        /**
         * Indicates which sorts of issues to return. Can be one of:
         * \* `assigned`: Issues assigned to you
         * \* `created`: Issues created by you
         * \* `mentioned`: Issues mentioning you
         * \* `subscribed`: Issues you're subscribed to updates for
         * \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
         */
        filter?:
          | "assigned"
          | "created"
          | "mentioned"
          | "subscribed"
          | "repos"
          | "all";
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        collab?: boolean;
        orgs?: boolean;
        owned?: boolean;
        pulls?: boolean;
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue"][];
        };
      };
      304: components["responses"]["not_modified"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
  };
  "meta/get": {
    parameters: {};
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["api-overview"];
        };
      };
      304: components["responses"]["not_modified"];
    };
  };
  "activity/list-public-events-for-repo-network": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
      301: components["responses"]["moved_permanently"];
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Lists the selected repositories that are enabled for GitHub Actions in an organization. To use this endpoint, the organization permission policy for `enabled_repositories` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization)."
   *
   * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
   */
  "actions/list-selected-repositories-enabled-github-actions-organization": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            repositories: components["schemas"]["repository"][];
          };
        };
      };
    };
  };
  /**
   * Gets the selected actions that are allowed in an organization. To use this endpoint, the organization permission policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for an organization](#set-github-actions-permissions-for-an-organization).""
   *
   * You must authenticate using an access token with the `admin:org` scope to use this endpoint. GitHub Apps must have the `administration` organization permission to use this API.
   */
  "actions/get-allowed-actions-organization": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["selected-actions"];
        };
      };
    };
  };
  "activity/list-public-org-events": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "orgs/list-webhooks": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["org-hook"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Returns a webhook configured in an organization. To get only the webhook `config` properties, see "[Get a webhook configuration for an organization](/rest/reference/orgs#get-a-webhook-configuration-for-an-organization)." */
  "orgs/get-webhook": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-hook"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * List issues in an organization assigned to the authenticated user.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /**
         * Indicates which sorts of issues to return. Can be one of:
         * \* `assigned`: Issues assigned to you
         * \* `created`: Issues created by you
         * \* `mentioned`: Issues mentioning you
         * \* `subscribed`: Issues you're subscribed to updates for
         * \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
         */
        filter?:
          | "assigned"
          | "created"
          | "mentioned"
          | "subscribed"
          | "repos"
          | "all";
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** List all pre-receive hooks that are enabled or testing for this organization as well as any disabled hooks that can be configured at the organization level. Globally disabled pre-receive hooks that do not allow downstream configuration are not listed. */
  "enterprise-admin/list-pre-receive-hooks-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** The sort order for the response collection. */
        sort?: "created" | "updated" | "name";
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-pre-receive-hook"][];
        };
      };
    };
  };
  "enterprise-admin/get-pre-receive-hook-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-pre-receive-hook"];
        };
      };
    };
  };
  /** Removes any overrides for this hook at the org level for this org. */
  "enterprise-admin/remove-pre-receive-hook-enforcement-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-pre-receive-hook"];
        };
      };
    };
  };
  /** For pre-receive hooks which are allowed to be configured at the org level, you can set `enforcement` and `allow_downstream_configuration` */
  "enterprise-admin/update-pre-receive-hook-enforcement-for-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["org-pre-receive-hook"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The state of enforcement for the hook on this repository. */
          enforcement?: string;
          /** Whether repositories can override enforcement. */
          allow_downstream_configuration?: boolean;
        };
      };
    };
  };
  /**
   * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
   *
   * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `application/vnd.github.v3.repository+json` accept header.
   *
   * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
   *
   * **Note:** You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
   */
  "teams/check-permissions-for-repo-in-org": {
    parameters: {
      path: {
        org: components["parameters"]["org"];
        /** team_slug parameter */
        team_slug: components["parameters"]["team-slug"];
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Alternative response with repository permissions */
      200: {
        content: {
          "application/json": components["schemas"]["team-repository"];
        };
      };
      /** Response if team has permission for the repository. This is the response when the repository media type hasn't been provded in the Accept header. */
      204: never;
      /** Not Found if team does not have permission for the repository */
      404: unknown;
    };
  };
  /**
   * When you pass the `scarlet-witch-preview` media type, requests to get a repository will also return the repository's code of conduct if it can be detected from the repository's code of conduct file.
   *
   * The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
   */
  "repos/get": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["full-repository"];
        };
      };
      301: components["responses"]["moved_permanently"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Gets the settings for selected actions that are allowed in a repository. To use this endpoint, the repository policy for `allowed_actions` must be configured to `selected`. For more information, see "[Set GitHub Actions permissions for a repository](#set-github-actions-permissions-for-a-repository)."
   *
   * You must authenticate using an access token with the `repo` scope to use this endpoint. GitHub Apps must have the `administration` repository permission to use this API.
   */
  "actions/get-allowed-actions-repository": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["selected-actions"];
        };
      };
    };
  };
  /**
   * Gets a single code scanning alert. You must use an access token with the `security_events` scope to use this endpoint. GitHub Apps must have the `security_events` read permission to use this endpoint.
   *
   * **Deprecation notice**:
   * The instances field is deprecated and will, in future, not be included in the response for this endpoint. The example response reflects this change. The same information can now be retrieved via a GET request to the URL specified by `instances_url`.
   */
  "code-scanning/get-alert": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The number that identifies an alert. You can find this at the end of the URL for a code scanning alert within GitHub, and in the `number` field in the response from the `GET /repos/{owner}/{repo}/code-scanning/alerts` operation. */
        alert_number: components["parameters"]["alert-number"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["code-scanning-alert"];
        };
      };
      403: components["responses"]["code_scanning_forbidden_read"];
      404: components["responses"]["not_found"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /** Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, additionally returns open pull requests associated with the commit. The results may include open and closed pull requests. Additional preview headers may be required to see certain details for associated pull requests, such as whether a pull request is in a draft state. For more information about previews that might affect this endpoint, see the [List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests) endpoint. */
  "repos/list-pull-requests-associated-with-commit": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** commit_sha parameter */
        commit_sha: components["parameters"]["commit-sha"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["pull-request-simple"][];
        };
      };
      415: components["responses"]["preview_header_missing"];
    };
  };
  /**
   * The `basehead` param is comprised of two parts: `base` and `head`. Both must be branch names in `repo`. To compare branches across other repositories in the same network as `repo`, use the format `<USERNAME>:branch`.
   *
   * The response from the API is equivalent to running the `git log base..head` command; however, commits are returned in chronological order. Pass the appropriate [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
   *
   * The response also includes details on the files that were changed between the two commits. This includes the status of the change (for example, if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
   *
   * **Working with large comparisons**
   *
   * The response will include a comparison of up to 250 commits. If you are working with a larger commit range, you can use the [List commits](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-commits) to enumerate all commits in the range.
   *
   * For comparisons with extremely large diffs, you may receive an error response indicating that the diff took too long
   * to generate. You can typically resolve this error by using a smaller commit range.
   *
   * **Signature verification object**
   *
   * The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
   *
   * | Name | Type | Description |
   * | ---- | ---- | ----------- |
   * | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
   * | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
   * | `signature` | `string` | The signature that was extracted from the commit. |
   * | `payload` | `string` | The value that was signed. |
   *
   * These are the possible values for `reason` in the `verification` object:
   *
   * | Value | Description |
   * | ----- | ----------- |
   * | `expired_key` | The key that made the signature is expired. |
   * | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
   * | `gpgverify_error` | There was an error communicating with the signature verification service. |
   * | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
   * | `unsigned` | The object does not include a signature. |
   * | `unknown_signature_type` | A non-PGP signature was found in the commit. |
   * | `no_user` | No user was associated with the `committer` email address in the commit. |
   * | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on her/his account. |
   * | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
   * | `unknown_key` | The key that made the signature has not been registered with any user's account. |
   * | `malformed_signature` | There was an error parsing the signature. |
   * | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
   * | `valid` | None of the above errors applied, so the signature is considered to be verified. |
   */
  "repos/compare-commits-with-basehead": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** The base branch and head branch to compare. This parameter expects the format `{base}...{head}`. */
        basehead: string;
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["commit-comparison"];
        };
      };
      404: components["responses"]["not_found"];
      500: components["responses"]["internal_error"];
    };
  };
  "activity/list-repo-events": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "repos/list-webhooks": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["hook"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/reference/repos#get-a-webhook-configuration-for-a-repository)." */
  "repos/get-webhook": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        hook_id: components["parameters"]["hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["hook"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * List issues in a repository.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** If an `integer` is passed, it should refer to a milestone by its `number` field. If the string `*` is passed, issues with any milestone are accepted. If the string `none` is passed, issues without milestones are returned. */
        milestone?: string;
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** Can be the name of a user. Pass in `none` for issues with no assigned user, and `*` for issues assigned to any user. */
        assignee?: string;
        /** The user that created the issue. */
        creator?: string;
        /** A user that's mentioned in the issue. */
        mentioned?: string;
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue-simple"][];
        };
      };
      301: components["responses"]["moved_permanently"];
      404: components["responses"]["not_found"];
      422: components["responses"]["validation_failed"];
    };
  };
  "issues/list-events-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue-event"][];
        };
      };
      422: components["responses"]["validation_failed"];
    };
  };
  "issues/get-event": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        event_id: number;
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["issue-event"];
        };
      };
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
      410: components["responses"]["gone"];
    };
  };
  /**
   * The API returns a [`301 Moved Permanently` status](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
   * [transferred](https://help.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
   * the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
   * returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
   * access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
   * to the [`issues`](https://docs.github.com/enterprise-server@3.1/webhooks/event-payloads/#issues) webhook.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/get": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** issue_number parameter */
        issue_number: components["parameters"]["issue-number"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["issue"];
        };
      };
      301: components["responses"]["moved_permanently"];
      304: components["responses"]["not_modified"];
      404: components["responses"]["not_found"];
      410: components["responses"]["gone"];
    };
  };
  /** List all pre-receive hooks that are enabled or testing for this repository as well as any disabled hooks that are allowed to be enabled at the repository level. Pre-receive hooks that are disabled at a higher level and are not configurable will not be listed. */
  "enterprise-admin/list-pre-receive-hooks-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        sort?: "created" | "updated" | "name";
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["repository-pre-receive-hook"][];
        };
      };
    };
  };
  "enterprise-admin/get-pre-receive-hook-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["repository-pre-receive-hook"];
        };
      };
    };
  };
  /**
   * Deletes any overridden enforcement on this repository for the specified hook.
   *
   * Responds with effective values inherited from owner and/or global level.
   */
  "enterprise-admin/remove-pre-receive-hook-enforcement-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Responds with effective values inherited from owner and/or global level. */
      200: {
        content: {
          "application/json": components["schemas"]["repository-pre-receive-hook"];
        };
      };
    };
  };
  /** For pre-receive hooks which are allowed to be configured at the repo level, you can set `enforcement` */
  "enterprise-admin/update-pre-receive-hook-enforcement-for-repo": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** pre_receive_hook_id parameter */
        pre_receive_hook_id: components["parameters"]["pre-receive-hook-id"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["repository-pre-receive-hook"];
        };
      };
    };
    requestBody: {
      content: {
        "application/json": {
          /** The state of enforcement for the hook on this repository. */
          enforcement?: "enabled" | "disabled" | "testing";
        };
      };
    };
  };
  /** Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://help.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation. */
  "pulls/list": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Either `open`, `closed`, or `all` to filter by state. */
        state?: "open" | "closed" | "all";
        /** Filter pulls by head user or head organization and branch name in the format of `user:ref-name` or `organization:ref-name`. For example: `github:new-script-format` or `octocat:test-branch`. */
        head?: string;
        /** Filter pulls by base branch name. Example: `gh-pages`. */
        base?: string;
        /** What to sort results by. Can be either `created`, `updated`, `popularity` (comment count) or `long-running` (age, filtering by pulls updated in the last month). */
        sort?: "created" | "updated" | "popularity" | "long-running";
        /** The direction of the sort. Can be either `asc` or `desc`. Default: `desc` when sort is `created` or sort is not specified, otherwise `asc`. */
        direction?: "asc" | "desc";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["pull-request-simple"][];
        };
      };
      304: components["responses"]["not_modified"];
      422: components["responses"]["validation_failed"];
    };
  };
  /**
   * This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/enterprise-server@3.1/rest/reference/repos#list-repository-tags).
   *
   * Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
   */
  "repos/list-releases": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["release"][];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * View the latest published full release for the repository.
   *
   * The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
   */
  "repos/get-latest-release": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
    };
  };
  /** Get a published release with the specified tag. */
  "repos/get-release-by-tag": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** tag parameter */
        tag: string;
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /** **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#hypermedia). */
  "repos/get-release": {
    parameters: {
      path: {
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
        /** release_id parameter */
        release_id: components["parameters"]["release-id"];
      };
    };
    responses: {
      /** **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a [hypermedia resource](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#hypermedia). */
      200: {
        content: {
          "application/json": components["schemas"]["release"];
        };
      };
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Lists all public repositories in the order that they were created.
   *
   * Note:
   * - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
   * - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#link-header) to get the URL for the next page of repositories.
   */
  "repos/list-public": {
    parameters: {
      query: {
        /** A repository ID. Only return repositories with an ID greater than this ID. */
        since?: components["parameters"]["since-repo"];
        /** Specifies the types of repositories to return. Can be one of `all` or `public`. Default: `public`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. */
        visibility?: "all" | "public";
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {
          Link?: string;
        };
        content: {
          "application/json": components["schemas"]["minimal-repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      422: components["responses"]["validation_failed"];
    };
  };
  /**
   * Find issues by state and keyword. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
   *
   * When searching for issues, you can get text match metadata for the issue **title**, issue **body**, and issue **comment body** fields when you pass the `text-match` media type. For more details about how to receive highlighted
   * search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
   *
   * For example, if you want to find the oldest unresolved Python bugs on Windows. Your query might look something like this.
   *
   * `q=windows+label:bug+language:python+state:open&sort=created&order=asc`
   *
   * This query searches for the keyword `windows`, within any open issue that is labeled as `bug`. The search runs across repositories whose primary language is Python. The results are sorted by creation date in ascending order, which means the oldest issues appear first in the search results.
   *
   * **Note:** For [user-to-server](https://docs.github.com/developers/apps/identifying-and-authorizing-users-for-github-apps#user-to-server-requests) GitHub App requests, you can't retrieve a combination of issues and pull requests in a single query. Requests that don't include the `is:issue` or `is:pull-request` qualifier will receive an HTTP `422 Unprocessable Entity` response. To get results for both issues and pull requests, you must send separate queries for issues and pull requests. For more information about the `is` qualifier, see "[Searching only issues or pull requests](https://docs.github.com/github/searching-for-information-on-github/searching-issues-and-pull-requests#search-only-issues-or-pull-requests)."
   */
  "search/issues-and-pull-requests": {
    parameters: {
      query: {
        /** The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.1/rest/reference/search#constructing-a-search-query). See "[Searching issues and pull requests](https://help.github.com/articles/searching-issues-and-pull-requests/)" for a detailed list of qualifiers. */
        q: string;
        /** Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://docs.github.com/enterprise-server@3.1/rest/reference/search#ranking-search-results) */
        sort?:
          | "comments"
          | "reactions"
          | "reactions-+1"
          | "reactions--1"
          | "reactions-smile"
          | "reactions-thinking_face"
          | "reactions-heart"
          | "reactions-tada"
          | "interactions"
          | "created"
          | "updated";
        /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
        order?: components["parameters"]["order"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            incomplete_results: boolean;
            items: components["schemas"]["issue-search-result-item"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /**
   * Find repositories via various criteria. This method returns up to 100 results [per page](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#pagination).
   *
   * When searching for repositories, you can get text match metadata for the **name** and **description** fields when you pass the `text-match` media type. For more details about how to receive highlighted search results, see [Text match metadata](https://docs.github.com/enterprise-server@3.1/rest/reference/search#text-match-metadata).
   *
   * For example, if you want to search for popular Tetris repositories written in assembly code, your query might look like this:
   *
   * `q=tetris+language:assembly&sort=stars&order=desc`
   *
   * This query searches for repositories with the word `tetris` in the name, the description, or the README. The results are limited to repositories where the primary language is assembly. The results are sorted by stars in descending order, so that the most popular repositories appear first in the search results.
   *
   * When you include the `mercy` preview header, you can also search for multiple topics by adding more `topic:` instances. For example, your query might look like this:
   *
   * `q=topic:ruby+topic:rails`
   */
  "search/repos": {
    parameters: {
      query: {
        /** The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://docs.github.com/enterprise-server@3.1/rest/reference/search#constructing-a-search-query). See "[Searching for repositories](https://help.github.com/articles/searching-for-repositories/)" for a detailed list of qualifiers. */
        q: string;
        /** Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://docs.github.com/enterprise-server@3.1/rest/reference/search#ranking-search-results) */
        sort?: "stars" | "forks" | "help-wanted-issues" | "updated";
        /** Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. */
        order?: components["parameters"]["order"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": {
            total_count: number;
            incomplete_results: boolean;
            items: components["schemas"]["repo-search-result-item"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      422: components["responses"]["validation_failed"];
      503: components["responses"]["service_unavailable"];
    };
  };
  /**
   * This endpoint allows you to check the status of the most recent configuration process:
   *
   * Note that you may need to wait several seconds after you start a process before you can check its status.
   *
   * The different statuses are:
   *
   * | Status        | Description                       |
   * | ------------- | --------------------------------- |
   * | `PENDING`     | The job has not started yet       |
   * | `CONFIGURING` | The job is running                |
   * | `DONE`        | The job has finished correctly    |
   * | `FAILED`      | The job has finished unexpectedly |
   */
  "enterprise-admin/get-configuration-status": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["configuration-status"];
        };
      };
    };
  };
  /** This endpoint allows you to start a configuration process at any time for your updated settings to take effect: */
  "enterprise-admin/start-configuration-process": {
    responses: {
      /** Response */
      202: unknown;
    };
  };
  /** Check your installation's maintenance status: */
  "enterprise-admin/get-maintenance-status": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["maintenance-status"];
        };
      };
    };
  };
  /** **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode). */
  "enterprise-admin/enable-or-disable-maintenance-mode": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["maintenance-status"];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /**
           * A JSON string with the attributes `enabled` and `when`.
           *
           * The possible values for `enabled` are `true` and `false`. When it's `false`, the attribute `when` is ignored and the maintenance mode is turned off. `when` defines the time period when the maintenance was enabled.
           *
           * The possible values for `when` are `now` or any date parseable by [mojombo/chronic](https://github.com/mojombo/chronic).
           */
          maintenance: string;
        };
      };
    };
  };
  "enterprise-admin/get-settings": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["enterprise-settings"];
        };
      };
    };
  };
  /**
   * For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#get-settings).
   *
   * **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
   */
  "enterprise-admin/set-settings": {
    responses: {
      /** Response */
      204: never;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** A JSON string with the new settings. Note that you only need to pass the specific settings you want to modify. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#get-settings). */
          settings: string;
        };
      };
    };
  };
  "enterprise-admin/get-all-authorized-ssh-keys": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["ssh-key"][];
        };
      };
    };
  };
  /** **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode). */
  "enterprise-admin/add-authorized-ssh-key": {
    responses: {
      /** Response */
      201: {
        content: {
          "application/json": components["schemas"]["ssh-key"][];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** The public SSH key. */
          authorized_key: string;
        };
      };
    };
  };
  /** **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode). */
  "enterprise-admin/remove-authorized-ssh-key": {
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["ssh-key"][];
        };
      };
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** The public SSH key. */
          authorized_key: string;
        };
      };
    };
  };
  /**
   * When you boot a GitHub instance for the first time, you can use the following endpoint to upload a license.
   *
   * Note that you need to `POST` to [`/setup/api/configure`](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#start-a-configuration-process) to start the actual configuration process.
   *
   * When using this endpoint, your GitHub instance must have a password set. This can be accomplished two ways:
   *
   * 1.  If you're working directly with the API before accessing the web interface, you must pass in the password parameter to set your password.
   * 2.  If you set up your instance via the web interface before accessing the API, your calls to this endpoint do not need the password parameter.
   *
   * **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
   */
  "enterprise-admin/create-enterprise-server-license": {
    responses: {
      /** Response */
      202: unknown;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** The content of your _.ghl_ license file. */
          license: string;
          /** You **must** provide a password _only if_ you are uploading your license for the first time. If you previously set a password through the web interface, you don't need this parameter. */
          password?: string;
          /** An optional JSON string containing the installation settings. For a list of the available settings, see the [Get settings endpoint](https://docs.github.com/enterprise-server@3.1/rest/reference/enterprise-admin#get-settings). */
          settings?: string;
        };
      };
    };
  };
  /**
   * This API upgrades your license and also triggers the configuration process.
   *
   * **Note:** The request body for this operation must be submitted as `application/x-www-form-urlencoded` data. You can submit a parameter value as a string, or you can use a tool such as `curl` to submit a parameter value as the contents of a text file. For more information, see the [`curl` documentation](https://curl.se/docs/manpage.html#--data-urlencode).
   */
  "enterprise-admin/upgrade-license": {
    responses: {
      /** Response */
      202: unknown;
    };
    requestBody: {
      content: {
        "application/x-www-form-urlencoded": {
          /** The content of your new _.ghl_ license file. */
          license?: string;
        };
      };
    };
  };
  /**
   * **Note**: Repositories inherited through a parent team will also be checked.
   *
   * **Deprecation Notice:** This endpoint route is deprecated and will be removed from the Teams API. We recommend migrating your existing code to use the new [Check team permissions for a repository](https://docs.github.com/enterprise-server@3.1/rest/reference/teams#check-team-permissions-for-a-repository) endpoint.
   *
   * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
   */
  "teams/check-permissions-for-repo-legacy": {
    parameters: {
      path: {
        team_id: components["parameters"]["team-id"];
        owner: components["parameters"]["owner"];
        repo: components["parameters"]["repo"];
      };
    };
    responses: {
      /** Alternative response with extra repository information */
      200: {
        content: {
          "application/json": components["schemas"]["team-repository"];
        };
      };
      /** Response if repository is managed by this team */
      204: never;
      /** Not Found if repository is not managed by this team */
      404: unknown;
    };
  };
  /**
   * List repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access for an installation.
   *
   * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
   *
   * You must use a [user-to-server OAuth access token](https://docs.github.com/enterprise-server@3.1/apps/building-github-apps/identifying-and-authorizing-users-for-github-apps/#identifying-users-on-your-site), created for a user who has authorized your GitHub App, to access this endpoint.
   *
   * The access the user has to each repository is included in the hash under the `permissions` key.
   */
  "apps/list-installation-repos-for-authenticated-user": {
    parameters: {
      path: {
        /** installation_id parameter */
        installation_id: components["parameters"]["installation-id"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** The access the user has to each repository is included in the hash under the `permissions` key. */
      200: {
        headers: {};
        content: {
          "application/json": {
            total_count: number;
            repository_selection?: string;
            repositories: components["schemas"]["repository"][];
          };
        };
      };
      304: components["responses"]["not_modified"];
      403: components["responses"]["forbidden"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * List issues across owned and member repositories assigned to the authenticated user.
   *
   * **Note**: GitHub's REST API v3 considers every pull request an issue, but not every issue is a pull request. For this
   * reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
   * the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
   * request id, use the "[List pull requests](https://docs.github.com/enterprise-server@3.1/rest/reference/pulls#list-pull-requests)" endpoint.
   */
  "issues/list-for-authenticated-user": {
    parameters: {
      query: {
        /**
         * Indicates which sorts of issues to return. Can be one of:
         * \* `assigned`: Issues assigned to you
         * \* `created`: Issues created by you
         * \* `mentioned`: Issues mentioning you
         * \* `subscribed`: Issues you're subscribed to updates for
         * \* `all` or `repos`: All issues the authenticated user can see, regardless of participation or creation
         */
        filter?:
          | "assigned"
          | "created"
          | "mentioned"
          | "subscribed"
          | "repos"
          | "all";
        /** Indicates the state of the issues to return. Can be either `open`, `closed`, or `all`. */
        state?: "open" | "closed" | "all";
        /** A list of comma separated label names. Example: `bug,ui,@high` */
        labels?: components["parameters"]["labels"];
        /** What to sort results by. Can be either `created`, `updated`, `comments`. */
        sort?: "created" | "updated" | "comments";
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["issue"][];
        };
      };
      304: components["responses"]["not_modified"];
      404: components["responses"]["not_found"];
    };
  };
  /**
   * Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
   *
   * The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
   */
  "repos/list-for-authenticated-user": {
    parameters: {
      query: {
        /** Can be one of `all`, `public`, or `private`. Note: For GitHub AE, can be one of `all`, `internal`, or `private`. */
        visibility?: "all" | "public" | "private";
        /**
         * Comma-separated list of values. Can include:
         * \* `owner`: Repositories that are owned by the authenticated user.
         * \* `collaborator`: Repositories that the user has been added to as a collaborator.
         * \* `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
         */
        affiliation?: string;
        /**
         * Can be one of `all`, `owner`, `public`, `private`, `member`. Note: For GitHub AE, can be one of `all`, `owner`, `internal`, `private`, `member`. Default: `all`
         *
         * Will cause a `422` error if used in the same request as **visibility** or **affiliation**. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
         */
        type?: "all" | "owner" | "public" | "private" | "member";
        /** Can be one of `created`, `updated`, `pushed`, `full_name`. */
        sort?: "created" | "updated" | "pushed" | "full_name";
        /** Can be one of `asc` or `desc`. Default: `asc` when using `full_name`, otherwise `desc` */
        direction?: "asc" | "desc";
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
        /** Only show notifications updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        since?: components["parameters"]["since"];
        /** Only show notifications updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. */
        before?: components["parameters"]["before"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
      422: components["responses"]["validation_failed"];
    };
  };
  /**
   * Lists repositories the authenticated user has starred.
   *
   * You can also find out _when_ stars were created by passing the following custom [media type](https://docs.github.com/enterprise-server@3.1/rest/overview/media-types/) via the `Accept` header:
   */
  "activity/list-repos-starred-by-authenticated-user": {
    parameters: {
      query: {
        /** One of `created` (when the repository was starred) or `updated` (when it was last pushed to). */
        sort?: components["parameters"]["sort"];
        /** One of `asc` (ascending) or `desc` (descending). */
        direction?: components["parameters"]["direction"];
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        headers: {};
        content: {
          "application/json": components["schemas"]["repository"][];
          "application/vnd.github.v3.star+json": components["schemas"]["starred-repository"][];
        };
      };
      304: components["responses"]["not_modified"];
      401: components["responses"]["requires_authentication"];
      403: components["responses"]["forbidden"];
    };
  };
  /** If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events. */
  "activity/list-events-for-authenticated-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  /** This is the user's organization dashboard. You must be authenticated as the user to view this. */
  "activity/list-org-events-for-authenticated-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
        org: components["parameters"]["org"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "activity/list-public-events-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  /** These are events that you've received by watching repos and following users. If you are authenticated as the given user, you will see private events. Otherwise, you'll only see public events. */
  "activity/list-received-events-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  "activity/list-received-public-events-for-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
      query: {
        /** Results per page (max 100) */
        per_page?: components["parameters"]["per-page"];
        /** Page number of the results to fetch. */
        page?: components["parameters"]["page"];
      };
    };
    responses: {
      /** Response */
      200: {
        content: {
          "application/json": components["schemas"]["event"][];
        };
      };
    };
  };
  /** Note that you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-verbs)." */
  "enterprise-admin/promote-user-to-be-site-administrator": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /** You can demote any user account except your own. */
  "enterprise-admin/demote-site-administrator": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
  };
  /**
   * If your GitHub instance uses [LDAP Sync with Active Directory LDAP servers](https://help.github.com/enterprise/admin/guides/user-management/using-ldap), Active Directory LDAP-authenticated users cannot be suspended through this API. If you attempt to suspend an Active Directory LDAP-authenticated user through this API, it will return a `403` response.
   *
   * You can suspend any user account except your own.
   *
   * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/enterprise-server@3.1/rest/overview/resources-in-the-rest-api#http-verbs)."
   */
  "enterprise-admin/suspend-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** The reason the user is being suspended. This message will be logged in the [audit log](https://help.github.com/enterprise/admin/articles/audit-logging/). If you don't provide a `reason`, it will default to "Suspended via API by _SITE\_ADMINISTRATOR_", where _SITE\_ADMINISTRATOR_ is the person who performed the action. */
          reason?: string;
        } | null;
      };
    };
  };
  /** If your GitHub instance uses [LDAP Sync with Active Directory LDAP servers](https://help.github.com/enterprise/admin/guides/user-management/using-ldap), this API is disabled and will return a `403` response. Active Directory LDAP-authenticated users cannot be unsuspended using the API. */
  "enterprise-admin/unsuspend-user": {
    parameters: {
      path: {
        username: components["parameters"]["username"];
      };
    };
    responses: {
      /** Response */
      204: never;
    };
    requestBody: {
      content: {
        "application/json": {
          /** The reason the user is being unsuspended. This message will be logged in the [audit log](https://help.github.com/enterprise/admin/articles/audit-logging/). If you don't provide a `reason`, it will default to "Unsuspended via API by _SITE\_ADMINISTRATOR_", where _SITE\_ADMINISTRATOR_ is the person who performed the action. */
          reason?: string;
        } | null;
      };
    };
  };
}

export interface external {}
